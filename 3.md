# 第3章

### パターンマッチ

```
ghci>lucky 7
"lucky number seven"

ghci>lucky 3
"sorry, you're out of luck, pal!"

ghci>lucky aaa
<interactive>:114:7: error: Variable not in scope: aaa :: Int
```

「すべての値」に合致するパターンを定義しないとエラーになる。

### タプルのパターンマッチ

```
first :: (a,b,c) -> a
first (x,_,_) = x

second :: (a,b,c) -> b
second (_,y,_) = y

third :: (a,b,c) -> c
third (_,_,z) = z
```

### リストのパターンマッチ

タプルのリストに対する内包表記にて、パターンマッチを使う。
マッチしない要素は結果のリストには含まれない。

```
listPatternMatch :: [(Int,Int)] -> [Int]
listPatternMatch xs = [ x * 100 + 3 | (x, 3) <- xs ]
```

普通のリストもパターンマッチできる。  

`[1,2,3]` は `1:2:3:[]` の糖衣構文なので、x:xs というパターンは、  
リストの先頭要素を `x` に束縛し、 `xs` に空のリストを束縛する。  
※再帰関数と一緒に良く使われる。

```
listSyntaxSugarMatch :: [Int] -> Int
listSyntaxSugarMatch (x:xs) = x

ghci>listSyntaxSugarMatch [1,2,3]
1

ghci>listSyntaxSugarMatch (1:2:3:[])
1
```

```
head' :: [a] -> a
head' [] = error "empty list"
head' (x:_) = x

ghci>head' [4,5,6]
4

ghci>head' []
*** Exception: empty list
CallStack (from HasCallStack):
  error, called at 3.hs:43:12 in main:Main

ghci>head' "Hello"
'H'
```

下記の `tell` 関数は、空リストにも単一要素のリストにも、2要素のリストにも、あるいはもっと多くの要素のリストにも合致するので、安全に使える。

```
tell :: (Show a) => [a] -> String
tell [] = "The list is empty"
tell (x:[]) = "The list has one element: " ++ show x
tell (x:y:[]) = "The list has two element: " ++ show x ++ " and " ++ show y
tell (x:y:_) = "The list is long. The first two element are: " ++ show x ++ " and " ++ show y
```

```
ghci>tell [1]
"The list has one element: 1"
ghci>tell [1]
"The list has one element: 1"
ghci>tell [True, False]
"The list has two element: True and False"
ghci>tell [1,2,3,4]
"The list is long. The first two element are: 1 and 2"
ghci>tell []
"The list is empty"
```

リストの要素数が固定であることを前提として関数は安全ではない。  
システムをクラッシュさせる可能性がある。

```
badAdd :: (Num a) => [a] -> a
badAdd (x:y:z:[]) = x + y + z

ghci>badAdd (1:2:3:[])
6
ghci>badAdd (1:2:3:4:[])
*** Exception: 3.hs:52:1-29: Non-exhaustive patterns in function badAdd
```

##### リストパターンマッチの注意点

2つのリストを繋げる演算子の `++` は使えない。  
※(xs ++ ys) に合致させようとしても、リストのどの部分を xs に合致させ、どの部分を ys に合致させればいいか、Haskell に伝えようがない。

### as パターン

パターンに分解しつつ、対象になった値も参照できる。
as パターンを作るには、普通のパターンの前に名前と @ を追加する。

```
firstLetter :: String -> String
firstLetter "" = "Empty string, whoops!"
firstLetter all@(x:xs) = "The first letter of " ++ all ++ " is " ++ [x]

ghci>firstLetter "Dracula"
"The first letter of Dracula is D"
```

### 場合分けして、きっちりガード

```
ghci>bmiTell 18.5
"You're underweight, you emo, you!"
ghci>bmiTell 25
"You're supporedly normal, Pffft, I bet you're ugly!"
ghci>bmiTell 30
"You're fat! Lose some weight, fatty!"
ghci>bmiTell 100
"You're a whale, congratulations!"
```
### 場合分けして、きっちりガード

ガードにはパイプ文字(|)に続く真理値式、さらにその四季が True に評価されたときに使われる関数本体につづく。式が False に評価されたら次のガードの評価に映移る。ガードはインデント必須(4つがおすすめ。

```
bmiTell :: Double -> String
bmiTell  bmi
    | bmi <= 18.5 = "You're underweight, you emo, you!"
    | bmi <= 25.0 = "You're supporedly normal,\
        \ Pffft, I bet you're ugly!"
    | bmi <= 30.0 = "You're fat! Lose some weight, fatty!"
    | otherwise = "You're a whale, congratulations!"
```

実行

```
ghci>bmiTell 18.5
"You're underweight, you emo, you!"
ghci>bmiTell 25
"You're supporedly normal, Pffft, I bet you're ugly!"
ghci>bmiTell 30
"You're fat! Lose some weight, fatty!"
ghci>bmiTell 100
"You're a whale, congratulations!"
```

if/else に比べて可読性が高い。
大抵の場合、関数の最後のガードはすべてをキャッチする otherwise になっている。

ガードは複数の引数を取る関数にも使える。

```
bmiTell' :: Double -> Double -> String
bmiTell' weight height
    |  weight / height ^ 2 <= 18.5 = "underweight"
    |  weight / height ^ 2 <= 25.5 = "normal"
    |  weight / height ^ 2 <= 30.0 = "fat"
    |  otherwise = "whale"
```

独自の `max` 関数を実装する。

```
max' :: (Ord a) => a -> a -> a
max' a b
    | a <= b = b
    | otherwise = a
```

独自の `compare` 関数を実装する。

```
myCompare :: (Ord a) => a -> a -> Ordering
a `myCompare` b
    | a == b = EQ
    | a <= b = LT
    | otherwise = GT
```

### where???

`where` を使って計算の中間結果に名前を付ける。

```
bmiTell3 :: Double -> Double -> String
bmiTell3 weight height
    |  bmi <= 18.5 = "underweight"
    |  bmi <= 25.5 = "normal"
    |  bmi <= 30.0 = "fat"
    |  otherwise = "whale"
    where bmi = weight / height ^ 2
```

ひとつまたは複数の変数や関数を定義できる。  
それらの変数はどのガードからも参照できる。  
修正範囲が少なくて済む。  
プログラム性能が向上する。  

複数の変数を定義するパターン。

```
bmiTell4 :: Double -> Double -> String
bmiTell4 weight height
    |  bmi <= skinny = "underweight"
    |  bmi <= normal = "normal"
    |  bmi <= fat    = "fat"
    |  otherwise = "whale"
    where bmi = weight / height ^ 2
          skinny = 18.5
          normal = 25.5
          fat    = 30.0
```

##### where のスコープ

where 節で定義した変数は、その関数からしか見えないので、他の関数の名前空間を汚染しない。
複数の関数から変数を参照したい場合はグローバルに定義する必要がある。

関数の違うパターンでの共有は変数をグローバルに定義しなければならない。


