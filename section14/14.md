# 第14章

さらにいくつかのモナドを紹介。  
それらを使うことで、普通の値のモナド値として扱えばプログラムがどんなにきれいに書けるかを体感していく。

モナドの世界を探検することで、モナドを認識し、使いこなすための感覚を磨いていく。

この章で登場するモナドは、すべて mtl パッケージの一部。  
mtl パッケージは Haskell Platform に入っている。

インストール済かどうか調べるためには、コマンドラインから `ghc-pkg list` と打てば良い。

## 14.1 Writer? 中の人なんていません!

```haskell
isBigGang :: Int -> Bool
isBigGang x = x > 9

-- 何をしたかを表す文字を同時に返す
isBigGang :: Int -> (Bool, String)
isBigGang x = (x > 9, "Compared gang size to 9.")
```

applyMaybe を実装した要領で applyLog を実装する

```haskell
applyLog :: (a, String) -> (a -> (b, String)) -> (b, String)
applyLog (x, log) f = let (y, newLog) = f x in (y, log ++ newLog)

ghci>(3, "hoge ") `applyLog` isBigGang
(False,"hoge Compared gang size to 9.")
ghci>(30, "fuga") `applyLog` isBigGang
(True,"fuga Compared gang size to 9.")

-- 盗賊団の人数にはじめからログがついていて、それが結果のログにも含まれる
-- x が文字列でも型の制約がないので applyLog は実行できる
ghci>("Tobin", "Got outlaw name.") `applyLog` (\x -> (length x, "Applied length."))
(5,"Got outlaw name.Applied length.")
ghci>("Bathcat", "Got outlaw name.") `applyLog` (\x -> (length x, "Applied length."))
(7,"Got outlaw name.Applied length.")
```

### モノイドが助けに来たよ

applyLog は (a, String) 型の値を取るようになっているが、ログは別に String である必要はない。  
ログへ追記するのには ++ を使っているのだから、文字のリストではなく、任意の型のリストが使えるはず。  

```haskell
applyLog :: (a, [c]) -> (a, -> (b, [c])) -> (b, [c])
```

リストを更に抽象化して Monoid として定義することで ++ していた箇所を mappned できるはず。

```haskell
ghci>[1,2,3] `mappend` [4,5,6]
[1,2,3,4,5,6]

ghci>B.pack [99,104,105] `mappend` B.pack [104,117,97,104,117,97]
"chihuahua"
```

ということで

```haskell
applyLog :: (Monoid m) => (a, m) -> (a -> (b, m)) -> (b, m)
applyLog (x, log) f = let (y, newLog) = f x in (y, log `mappend` newLog)
```

これで applyLog が不可する値は任意のモノイド値になったので、別にタプルを「値とログの組」と解釈する必要はなくなった。

いまや「値と、モノイド値のおまけ」とみなすことができる。

```haskell
-- 食事と飲み物をセットで注文する関数
import Data.Monoid

type Food = String
type Price = Sum Int

addDrink :: Food -> (Food, Price)
addDrink "beans" = ("milk", Sum 25)
addDrink "jerky" = ("whiskey", Sum 99)
addDrink _ = ("beer", Sum 30)
```

- 豆を食べているときは、 milk と一緒に Sum 25 を返す
- ジャーキーを食べているときは whiskey
- それ以外のものを食べているときはビール

applyLog を使って適用してみる。

```haskell
ghci>("beans", Sum 10) `applyLog` addDrink
("milk",Sum {getSum = 35})

ghci>("jerky", Sum 25) `applyLog` addDrink
("whiskey",Sum {getSum = 124})
ghci>("dogmeat", Sum 5) `applyLog` addDrink
("beer",Sum {getSum = 35})

-- 以下のようにチェーン可能
ghci>("dogmeat", Sum 5) `applyLog` addDrink `applyLog` addDrink
("beer",Sum {getSum = 65})
```

### Writer型

`Control.Monad.Writer` というのがある。  
Writer w a 型とその Monad インスタンス、それに Writer w a 型を扱うための便利な関数をエクスポート
している。

値にモノイドのおまけをつけるには、タプルに入れるだけ。  
Writer w a 型の実態は、そんなタプルの newtype ラッパーに過ぎず、定義はとてもシンプル。

```haskell
newtype Writer w a = Writer { runWriter :: (a, w) }
```

- 型引数a が主となる値の型を表している
- 型引数w がおまけのモノイド値の型を表している
- Writer 値のコンストラクタがない代わりに writer 関数を使う
  - これを使えばタプルを Writer 値に変更できる
- Writer 値コンストラクタがエクスポートされていないのでパターンマッチできない
  - その代わり runWriter 関数を使う >> 中身のタプルを取り出せる

```haskell
ghci>runWriter (return 3 :: Writer String Int)
(3,"")
ghci>runWriter (return 3 :: Writer (Sum Int) Int)
(3,Sum {getSum = 0})
ghci>runWriter (return 3 :: Writer (Product Int) Int)
(3,Product {getProduct = 1})
```

fail を実装していないのでdo記法でパターンマッチングに失敗すると error が返る。

### Writer を do 記法で使う

do記法は複数の Writer をまとめて何かしたいときに便利。

- プログラマーにとっては普通の値のように扱える
- その裏でモナドが文脈の面倒を見てくれる

Writer を do記法で使い、2つの数を掛け算する例。

```haskell
logNumber :: Int -> Writer [String] Int
logNumber x = writer (x, ["Got number: " ++ show x])

multWithLog :: Writer [String] Int
multWithLog = do
    a <- logNumber 3
    b <- logNumber 5
    return (a*b)
```

モノイドだけを追加したい場合は tell を使うと便利。  
tell は MonadWriter 型クラスの一部。

Writer の場合は、モノイド値、例えば `["This is going on"]` を取り、  
ダミー値 () を返しつつ、モノイド値を追記する Writer を返す。

```haskell
multWithLog :: Writer [String] Int
multWithLog = do
    a <- logNumber 3
    b <- logNumber 5
    tell ["Gonna multiply these two"]
    return (a*b)
```

### プログラムにログを追加しよう

ユークリッド互除法は、２つの数を取ってその最大公約数(2つの数をどちらも割り切れる数のうち最大のも)  
を求めるアルゴリズム。

Haskell には、そのもの gcd 関数がすでにある。

```haskell
ghci>gcd 24 36
12
```

ログを残す機能を付いたバージョンを自前で作ってみましょう。

```haskell
gcd' :: Int -> Int -> Int
gcd' a b
    | b == 0 = a
    | otherwise = gcd' b (a `mod` b)

ghci>gcd' 8 3
1
```

この結果に、ログの役割を果たすモノイド値、という文脈を付ける。

```haskell
gcd' :: Int -> Int -> Writer [String] Int

import Control.Monad.Writer

gcd' :: Int -> Int -> Writer [String] Int
gcd' a b
    | b == 0 = do
        tell ["Finished with " ++ show a]
        return a
    | otherwise = do
        tell [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)]
        gcd' b (a `mod` b)
```

b が 0 のときは a を返す。

b が 0 でない場合

- mod を使って a を b で割った余りを求めたことを記録しておく
- gcd' を再帰的に呼び出す
  - gcd' は最後には Writer 値を返すので `gcd' b (a `mod` b)` を do 式の結果行に置いておくのは完全に正しいことだとわかる

```haskell
ghci>fst $ runWriter (gcd' 8 3)
1

ghci>mapM_ putStrLn $ snd $ runWriter (gcd' 8 3)
8 mod 3 = 2
3 mod 2 = 1
2 mod 1 = 0
Finished with 1
```

こんなふうに、普通のアルゴリズムを実行中に何をしているか報告するアルゴリズムに返ることができる。  
普通の値をモナド値に返るだけで、それができるのですごい。  
ログを集める作業は Writer の >>= の実装が勝手にやってくれる。

### 非効率なリスト構築

Writer モナドを使うときは、使うモナドに気をつけるべし。  
リストを使う時はとても遅くなる場合がある。

mappend に ++ を使っているが ++ を使ってリストの最後にものを追加する操作は、  
そのリストがとても長いと遅くなってしまう。

gcd' 関数のログ取りは早いほうだった。  
なぜなら、最終的に行われるリスト結合演算は以下のようになっていたからである。

```haskell
a ++ (b ++ (c ++ (d ++ (e ++ f))))
```

リストは左から右へ構築されるデータ構造。  
これが効率的なのは、まずリストの左辺を最後まで構築し、それから初めて右辺の長いリストを結合しているから。

うっかりすると以下のようなコードができかねない。

```haskell
(((("a" ++ "b") ++ "c") ++ "d") ++"e") ++ "a"
```

これは左結合。このコードは右辺を左辺に結合しようとするたびに、左辺をはじめから構築しなければならない。  
これから見せる関数は gcd' とにているが、ログの出力が逆順になっている。

再帰の各ステップは、まずプログラムの残りの部分のログを全部出力してから今のステップをログの最後に追加するようになっている。

```haskell
import Control.Monad.Writer

gcdReserve' :: Int -> Int -> Writer [String] Int
gcdReserve' a b
    | b == 0 = do
        tell ["Finished with " ++ show a]
        return a
    | otherwise = do
        result <- gcdReserve' b (a `mod` b)
        tell [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)]
        return result

ghci>mapM_ putStrLn $ snd $ runWriter (gcdReserve' 8 3)
Finished with 1
2 mod 1 = 0
3 mod 2 = 1
8 mod 3 = 2
```

こいつは、まず再帰を呼び出してその結果を result という変数に束縛する。  
それから今のステップをログに追加するので、現在のステップは再帰が生成したログの最後にくる。  
最後に、再帰の結果を自信の計算結果として提示している。

この関数は、++ を右結合ではなく左結合で使ってしまうので、非効率的。  
このようなやり方で結合していくとリストでは非効率になってしまう場合があるので、  
常に効率的な結合をサポートするデータ構造を使うのが一番良い。

そのようなデータ構造の１つが差分リスト

### 差分リスト

通常のリストに似ている差分リストだが、その実態はリストを取って別のリストを先頭に付け加える関数。  
例えば [1,2,3] と等価な差分リストは `\xs -> [1,2,3] ++ xs` である。

通常の空リストは [] だが、空の差分リストは関数 `\xs -> [] ++ xs` として表される

差分リストは効率の良いリスト結合をサポートする。  
普通のリストを2つ、++ で結合するときは、左辺のリストを最後まで延々と辿っていって、そこに右辺をくっつけなければならない。

でも、差分リストというアプローチをとってリストを関数として表現すると、何が起きるか？  
2つの差分リストを結合する操作は下記のようになる。

```haskell
f `append` g = \xs -> f (g xs)
```

f, g はリストを取ってその前に何かを付ける関数だった。  
例えば、("dog"++) (別の書き方をすると \xs -> "dog" ++ xs) という関数で、  
g が ("meat"++) という関数なら、 f `append` g は次の関数と等価となる。

```haskell
\xs -> "dog" ++ ("meat" ++ xs)
```

引数にまず2つ目の差分リスト、続いて1つ目の差分リストを適用する関数になる。  
差分リストの newtype ラッパーを作ると、そうすればモノイドインスタンスを作るのが楽。

```haskell
newtype DiffList a = DiffList { getDiffList :: [a] -> [a] }
```

包まれているものの型は [a] -> [a]  
差分リストは、リストを取って同じ型のリストを返す関数に過ぎない。普通のリストを差分リストに変更したり、その逆をするのは簡単。

```haskell
toDiffList :: [a] -> DiffList a
toDiffList xs = DiffList (xs++)

fromDiffList :: DiffList a -> [a]
fromDiffList (DiffList f) = f []
```

DiffList の Monoid インスタンスはこのようになっている

```haskell
instance Semigroup (DiffList a) where
    (DiffList f) <> (DiffList g) = DiffList (\xs -> f (g xs))

instance Monoid (DiffList a) where
    mempty = DiffList (\xs -> [] ++ xs)
    mappend = (<>)
```

```haskell
$ fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3])
```

```haskell
gcd' :: Int -> Int -> Writer (DiffList String) Int
gcd' a b
    | b == 0 = do
        tell (toDiffList ["Finished with " ++ show a])
        return a
    | otherwise = do
        result <- gcd' b (a `mod` b)
        tell (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
        return result
```

動かないからやめた。

## 14.2 Reader? それはあなたです!

# note

## foldRight

- リストから新しいリストを作成するときに使う
- スタックオーバーフローが起こりうる
- 要素数が多いリストの走査には適さない

## foldLeft

- リストの走査および畳み込みに使う
- スタックセーフ
- リストの構築には向かない