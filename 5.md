# 高階関数

引数として関数を受け取る関数。これを高階関数という。

### 5.1 カリー化関数

複数の引数を受け取れるように見えたのはカリー化された関数であるから。  
カリー化関数が呼ばれると、その次の引数を受け取る関数を返す。その繰り返し。

max 関数の型

```
ghci>:t max
max :: Ord a => a -> a -> a
```

`->` を型シグネチャに含むものはすべて関数。
つまり左側にあるものを引数に取り、右側にあるものを型とする値を返す。

関数を本来より少ない引数で呼び出したときに部分適用された関数が得られる。  
部分適用 → 本来より少ない引数で呼び出すこと。

部分適用を使うと関数をその場でお手軽に作り出して、それを他の関数に渡せる。

```
multThree :: Int -> Int -> Int -> Int
multThree :: x y z = x * y * z
```

multiThree 3 5 9 あるいは ((multiThree 3) 5) 9 を呼び出すと何がおこるのか。

1. multiThree が 3 に適用され、「引数を１つ取って関数を返す関数」が返る。
2. 上記の関数が 5 に適用され、「引数を取って 3 と 5 を掛けた数を返す関数」ができる。
3, 上記の関数が 9 に適用され、135 が最終的な結果となる。

関数は何か材料を受け取って何かを作り出す小さな工場だと考えられる。  
`multiThree` の型は次のようにも書ける。

multiThree :: Int -> (Int -> (Int -> Int))

->の前にあるのは関数が受け取る値の型。後ろにあるのは返り値の型。
なので、この関数は Int 型の値を受け取り、(Int -> (Int -> Int)) という型を返す。  
最後にこの関数は Int 型の値を受け取り、Int型の値を返す。

本来より少ない引数で関数を呼び出すことによって新しい関数を作る例を見ていく。

```
ghci>let multTwoWithNine = multThree 9
ghci>multTwoWithNine 2 3
```

上記の例では、式 `multThree 9` の結果は2引数の関数になる。  
この関数に `multTwoWithNine` という名前を付けている。
`multThree 9` は2つ引数を取る関数のためである。

Int を引数に取って100と比較する関数を作る。

```
compareWithHundred :: Int -> Ordering
compareWithHundred x = compare 100 x
```

100は99より大きいのでGTとなる。  
答は「数を引数に取り100と比較する関数」。  
以下の定義と等価。

```
compareWithHundred :: Int -> Ordering
compareWithHundred = compare 100
```

##### セクション

中置関数に対してセクションという機能を使って部分適用することができる。  
中置関数をセクションするには片側だけに値を置いて括弧で囲むだけ。  
これで引数を一つ、値を置かなかった側に取る関数ができる。

```haskell
divideByTen :: (Floating a) => a -> a
divideByTen = (/10)
```

以下は、それぞれ等価となる。

```haskell
ghci>divideByTen 200
20.0
ghci>200 /10
20.0
ghci>(/10) 200
20.0
```

セクションで唯一気をつけなければならないのは、- (負の数、マイナス)演算子と同時につかうとき。  
(-4)は、セクションの定義から考えると、数を受け取ってそれから4を引く関数になると思われる。  
しかし(-4)は、利便性のために、マイナス4を意味することになっている。なので、引数から4を引き算する関数を作りたいときには、  
`substract` 関数を `(substract 4)` のように部分適用する。

##### 関数を表示する

関数そのものをターミナルに表示する。  
`multThree 3 4` をそのままGHCiに打ち込んでみる。

```haskell
ghci>multThree 3 4

<interactive>:14:1: error:
    • No instance for (Show (Int -> Int)) arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
```

GHCiは、この式が a -> a の型の関数を生成しあけど、それをどうやって画面に表示したらいいか分からないといっている。  
関数は Show 型クラスのインスタンスではないので、いい感じに関数を表現する文字列がえられない。  

これは、例えば 1 + 1 のような式を入力した場合とはことなる。  
この場合、GHCiは式の結果として2を計算し、それから2に対して show を読んで、数のテキスト表現を得る。  
2のテキスト表現は単に文字列 "2" なので、これがスクリーンに表示される。

### 高階実演

すでに説明したとおり、Haskell では関数は別の関数を引数として受け取ることも、返り値として関数を返すこともできる。  
このコンセプトの実演として、関数を受け取り、それを2回適用する関数を書いてみる。

```haskell
applyTwice :: (a -> a) -> a -> a
applyTwice f x = f (f x)
```

`(a -> a)` は 「「1つの引数を取り、同じかたの値を返す関数」だということを示している。  
２つ目の引数は何かのa型の値で、返り値もa型。aは何の型、つまりIntでもStringでも、あるいはもっとほかの型でもかまわない。  
しかし、すべてのaは同じ型でなければならにことに注意。

applyTwice は第一引数の関数を第二引数の値に対し二度適用する関数。

```haskell
ghci>applyTwice (+3) 10
16
ghci>applyTwice (++ " HAHA") "HEY"
"HEY HAHA HAHA"
ghci>applyTwice (multThree 2 2) 9
144
ghci>applyTwice (3:) [1]
[3,3,1]
```

部分適用のすごさと実用性が歴然とわかる。  

##### zipWith を実装する

*zipWith* を実装する。*zipWith* は関数と2つのリストを引数にとり、2つのリストの各要素にその関数を適用することで、  
2つのリストを1つに結合する。

```haskell
zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith' _ [] _ = []
zipWith' _ _ [] = []
zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys
```

+ １つ目の引数は、引数を２つ取り値を１つ返す関数。
+ ２つ目と３つ目の引数はリスト。
+ 最初のリストはa型の値のリストでなければならない。
   + なぜならリストの結合に使う関数が第一引数としてaという型をとるため。
+ ２番目のリストは同様の理由でb型でなければならない。
+ 結果はc型の要素のリストとなる。

```haskell
ghci>zipWith' (+) [4,2,5,6] [ 2,6,2,3]
[6,8,7,9]
ghci>zipWith' max [6,3,2,1] [7,3,1,5]
[7,3,2,5]
ghci>zipWith
zipWith   zipWith'  zipWith3
ghci>zipWith' (++) ["foo", "bar", "baz"] ["fighters", "hoppers", "aldrin"]
["foofighters","barhoppers","bazaldrin"]
ghci>zipWith' (*) (replicate 5 2) [1..]
[2,4,6,8,10]
ghci>zipWith' (zipWith' (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]]
[[3,4,6],[9,20,30],[10,12,12]]
```

##### flip を実装する

flip関数は関数を引数に取り、元の関数に似ているけど最初の２つの引数が入れ替わった関数を返す。

```haskell
flip' :: (a -> b -> c) -> (b -> a -> c)
flip' f = g
    where g x y = f y x
```

型宣言からflip'は「a型とb型の値を引数に取る関数」を引数に取り、  
「b型とa型の値を引数に取る関数」を返す。

なお、関数はデフォルトでカリー化されているので、２つ目の括弧は厳密には必要ない。矢印 *->* は、  
デフォルトで右結合なので以下の型定義はすべて同じ。 

+ **(a -> b -> c) -> (b -> a -> c)**
+ **(a -> b -> c) -> (b -> (a -> c))**
+ **(a -> b -> c) -> b -> a -> c**

上のコードでは、*g x y = f y x* と書いたが、*f y x = g x y* もまた成り立つ。  
これを踏まえると flip' の実装をもっと簡潔にできる。

```haskell
flip'' :: (a -> b -> c) -> (b -> a -> c)
flip'' f y x = g x y
```

この新しいバージョンのflip''は、関数がカリー化されていることをうまく使っている。  
*flip'' f* を引数yとxなしで呼び出すと、2つの引数を取る、引数の入れ替わったfが返る。

flipされた関数を、また別の関数にわたすこともよくある。  
そんな場合でも、関数が完全に適用されたらどんな結果になるのかをよく考えてみたり。  
結果を書き下してみたりすれば、高階関数を作るときにカリー化がうまく利用できる。  

```haskell
ghci>zip [1,2,3,4,5] "hello"
[(1,'h'),(2,'e'),(3,'l'),(4,'l'),(5,'o')]
ghci>flip'' zip [1,2,3,4,5] "hello"
[('h',1),('e',2),('l',3),('l',4),('o',5)]
ghci>zipWith div [2,2..] [10,8,6,4,2]
[0,0,0,0,1]
ghci>zipWith (flip'' div) [2,2..] [10,8,6,4,2]
[5,4,3,2,1]
```
