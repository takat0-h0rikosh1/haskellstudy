# 高階関数

引数として関数を受け取る関数。これを高階関数という。

### 5.1 カリー化関数

複数の引数を受け取れるように見えたのはカリー化された関数であるから。  
カリー化関数が呼ばれると、その次の引数を受け取る関数を返す。その繰り返し。

max 関数の型

```
ghci>:t max
max :: Ord a => a -> a -> a
```

`->` を型シグネチャに含むものはすべて関数。
つまり左側にあるものを引数に取り、右側にあるものを型とする値を返す。

関数を本来より少ない引数で呼び出したときに部分適用された関数が得られる。  
部分適用 → 本来より少ない引数で呼び出すこと。

部分適用を使うと関数をその場でお手軽に作り出して、それを他の関数に渡せる。

```
multThree :: Int -> Int -> Int -> Int
multThree :: x y z = x * y * z
```

multiThree 3 5 9 あるいは ((multiThree 3) 5) 9 を呼び出すと何がおこるのか。

1. multiThree が 3 に適用され、「引数を１つ取って関数を返す関数」が返る。
2. 上記の関数が 5 に適用され、「引数を取って 3 と 5 を掛けた数を返す関数」ができる。
3, 上記の関数が 9 に適用され、135 が最終的な結果となる。

関数は何か材料を受け取って何かを作り出す小さな工場だと考えられる。  
`multiThree` の型は次のようにも書ける。

multiThree :: Int -> (Int -> (Int -> Int))

->の前にあるのは関数が受け取る値の型。後ろにあるのは返り値の型。
なので、この関数は Int 型の値を受け取り、(Int -> (Int -> Int)) という型を返す。  
最後にこの関数は Int 型の値を受け取り、Int型の値を返す。

本来より少ない引数で関数を呼び出すことによって新しい関数を作る例を見ていく。

```
ghci>let multTwoWithNine = multThree 9
ghci>multTwoWithNine 2 3
```

上記の例では、式 `multThree 9` の結果は2引数の関数になる。  
この関数に `multTwoWithNine` という名前を付けている。
`multThree 9` は2つ引数を取る関数のためである。

Int を引数に取って100と比較する関数を作る。

```
compareWithHundred :: Int -> Ordering
compareWithHundred x = compare 100 x
```

100は99より大きいのでGTとなる。  
答は「数を引数に取り100と比較する関数」。  
以下の定義と等価。

```
compareWithHundred :: Int -> Ordering
compareWithHundred = compare 100
```

##### セクション

中置関数に対してセクションという機能を使って部分適用することができる。  
中置関数をセクションするには片側だけに値を置いて括弧で囲むだけ。  
これで引数を一つ、値を置かなかった側に取る関数ができる。

```haskell
divideByTen :: (Floating a) => a -> a
divideByTen = (/10)
```

以下は、それぞれ等価となる。

```haskell
ghci>divideByTen 200
20.0
ghci>200 /10
20.0
ghci>(/10) 200
20.0
```

セクションで唯一気をつけなければならないのは、- (負の数、マイナス)演算子と同時につかうとき。  
(-4)は、セクションの定義から考えると、数を受け取ってそれから4を引く関数になると思われる。  
しかし(-4)は、利便性のために、マイナス4を意味することになっている。なので、引数から4を引き算する関数を作りたいときには、  
`substract` 関数を `(substract 4)` のように部分適用する。

##### 関数を表示する

関数そのものをターミナルに表示する。  
`multThree 3 4` をそのままGHCiに打ち込んでみる。

```haskell
ghci>multThree 3 4

<interactive>:14:1: error:
    • No instance for (Show (Int -> Int)) arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
```

GHCiは、この式が a -> a の型の関数を生成しあけど、それをどうやって画面に表示したらいいか分からないといっている。  
関数は Show 型クラスのインスタンスではないので、いい感じに関数を表現する文字列がえられない。  

これは、例えば 1 + 1 のような式を入力した場合とはことなる。  
この場合、GHCiは式の結果として2を計算し、それから2に対して show を読んで、数のテキスト表現を得る。  
2のテキスト表現は単に文字列 "2" なので、これがスクリーンに表示される。

### 高階実演

すでに説明したとおり、Haskell では関数は別の関数を引数として受け取ることも、返り値として関数を返すこともできる。  
このコンセプトの実演として、関数を受け取り、それを2回適用する関数を書いてみる。

```haskell
applyTwice :: (a -> a) -> a -> a
applyTwice f x = f (f x)
```

`(a -> a)` は 「「1つの引数を取り、同じかたの値を返す関数」だということを示している。  
２つ目の引数は何かのa型の値で、返り値もa型。aは何の型、つまりIntでもStringでも、あるいはもっとほかの型でもかまわない。  
しかし、すべてのaは同じ型でなければならにことに注意。

applyTwice は第一引数の関数を第二引数の値に対し二度適用する関数。

```haskell
ghci>applyTwice (+3) 10
16
ghci>applyTwice (++ " HAHA") "HEY"
"HEY HAHA HAHA"
ghci>applyTwice (multThree 2 2) 9
144
ghci>applyTwice (3:) [1]
[3,3,1]
```

部分適用のすごさと実用性が歴然とわかる。  

##### zipWith を実装する

*zipWith* を実装する。*zipWith* は関数と2つのリストを引数にとり、2つのリストの各要素にその関数を適用することで、  
2つのリストを1つに結合する。

```haskell
zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith' _ [] _ = []
zipWith' _ _ [] = []
zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys
```

+ １つ目の引数は、引数を２つ取り値を１つ返す関数。
+ ２つ目と３つ目の引数はリスト。
+ 最初のリストはa型の値のリストでなければならない。
   + なぜならリストの結合に使う関数が第一引数としてaという型をとるため。
+ ２番目のリストは同様の理由でb型でなければならない。
+ 結果はc型の要素のリストとなる。

```haskell
ghci>zipWith' (+) [4,2,5,6] [ 2,6,2,3]
[6,8,7,9]
ghci>zipWith' max [6,3,2,1] [7,3,1,5]
[7,3,2,5]
ghci>zipWith
zipWith   zipWith'  zipWith3
ghci>zipWith' (++) ["foo", "bar", "baz"] ["fighters", "hoppers", "aldrin"]
["foofighters","barhoppers","bazaldrin"]
ghci>zipWith' (*) (replicate 5 2) [1..]
[2,4,6,8,10]
ghci>zipWith' (zipWith' (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]]
[[3,4,6],[9,20,30],[10,12,12]]
```

##### flip を実装する

flip関数は関数を引数に取り、元の関数に似ているけど最初の２つの引数が入れ替わった関数を返す。

```haskell
flip' :: (a -> b -> c) -> (b -> a -> c)
flip' f = g
    where g x y = f y x
```

型宣言からflip'は「a型とb型の値を引数に取る関数」を引数に取り、  
「b型とa型の値を引数に取る関数」を返す。

なお、関数はデフォルトでカリー化されているので、２つ目の括弧は厳密には必要ない。矢印 *->* は、  
デフォルトで右結合なので以下の型定義はすべて同じ。 

+ **(a -> b -> c) -> (b -> a -> c)**
+ **(a -> b -> c) -> (b -> (a -> c))**
+ **(a -> b -> c) -> b -> a -> c**

上のコードでは、*g x y = f y x* と書いたが、*f y x = g x y* もまた成り立つ。  
これを踏まえると flip' の実装をもっと簡潔にできる。

```haskell
flip'' :: (a -> b -> c) -> (b -> a -> c)
flip'' f y x = g x y
```

この新しいバージョンのflip''は、関数がカリー化されていることをうまく使っている。  
*flip'' f* を引数yとxなしで呼び出すと、2つの引数を取る、引数の入れ替わったfが返る。

flipされた関数を、また別の関数にわたすこともよくある。  
そんな場合でも、関数が完全に適用されたらどんな結果になるのかをよく考えてみたり。  
結果を書き下してみたりすれば、高階関数を作るときにカリー化がうまく利用できる。  

```haskell
ghci>zip [1,2,3,4,5] "hello"
[(1,'h'),(2,'e'),(3,'l'),(4,'l'),(5,'o')]
ghci>flip'' zip [1,2,3,4,5] "hello"
[('h',1),('e',2),('l',3),('l',4),('o',5)]
ghci>zipWith div [2,2..] [10,8,6,4,2]
[0,0,0,0,1]
ghci>zipWith (flip'' div) [2,2..] [10,8,6,4,2]
[5,4,3,2,1]
```

### 関数プログラマの道具箱

関数プログラマは数や文字や他の型のデータのあつまりを受け取り、その集合を変換して結果を得たいもの。
この節では、複数の値を使って仕事をするときに便利な関数を見ていくことにする。

##### map関数

map関数は関数とリストを受け取って、その関数をリストのすべての要素に適用して新しいリストを生成する。

```haskell
map :: (a -> b) -> [a] -> [b]
map _ [] = []
map f (x:xs) = f x : map f xs
```

mapはいろいろな使い方ができる多彩な関数。

```haskell
ghci>map (+3) [1,5,3,1,6]
[4,8,6,4,9]
ghci>map (++ "!") ["BIFF", "BANG", "POW"]
["BIFF!","BANG!","POW!"]
ghci>map (map (^2)) [[1,2],[3,4,5,6],[7,8]]
[[1,4],[9,16,25,36],[49,64]]
ghci>map fst [(1,2),(3,5),(6,3),(2,6),(2,5)]
[1,3,6,2,2]
```

map関数と同様のことがリスト内包表記を使って同じことができる。  
下記のふたつの式は同等となる。

```haskell
map (+3) [1,5,3,1,6]
[x+3 | x <- [1,5,3,1,6]]
```

mapのほうが読みやすい。

##### filter関数

filter関数は述語とリストを受け取って、そのリストの要素のうち、述語をみたすもののみからなるリストを返す。
※述語とは、何がtrueで何がfalseかを言う関数。つまり真理値を返す関数。

```haskell
filter :: (a -> Bool) -> [a] -> [b]
filter _ [] = []
filter p (x:xs)
    | p x = x : filter p xs
    | otherwise = filter p xs
```

filterの例

```haskell
ghci>let notNull x = not (null x) in filter notNull [[1,2,3],[],[3,4,5],[2,2],[],[],[]]
[[1,2,3],[3,4,5],[2,2]]
ghci>:t not
not :: Bool -> Bool
ghci>filter (`elem` ['a'..'z']) "u LaUgH aT mE BeCaUsE I aM diFfeRent"
"uagameasadifeent"
ghci>filter (`elem` ['A'..'Z']) "i LAuGh at you bEcause u R all the same"
"LAGER"
```

これらもmapのときと同様にリスト内包表記と述語を使って書ける。
リスト内包表記で複数の述語を指定するようなケースをfilterで書くときには、filterを何度か適用するか、
述語を論理関数 && でつないで指定する。

```haskell
ghci>filter (<15) (filter even [1..20])
[2,4,6,8,10,12,14]
```

この例では、リスト [1..20] を受け取り、偶数だけ残すようにフィルタしている。そのあと、リストを filter (<15) に渡し、15以上の数を取り除いている。リスト内包表記ならこうなる。

```haskell
[x | x <- [1..20], x < 15, even x]
```

以前、実装した quicksort 関数はは filter を使えばもっと読みやすくなる。

```haskell
quicksort :: (Ord a) => [a] -> [b]
quicksort [] = []
quicksort (x:xs) =
    let smallerOrEqual = filter (<= x) xs
        larger = filter (> x) xs
    in  quicksort smallerOrEqual ++ [x] ++ quicksort larger
```

##### mapとfilterのさらなる例

ex). 10万以下の数のうち3829で割り切れる最大の数を探す。  
それには、解があるとわかっている範囲から解になり得る集合をフィルタするだけ。

```haskell
largestDivisible :: Integer
largestDivisible = head (filter p [100000,99999..])
    where p x = x `mod` 3829 == 0
```

ex). 10000 より小さいすべての奇数の平方数の和をもとめる。

これには takeWhile という関数を使う。この関数は述語とリストを受け取り、  
リストの先頭から始めて述語の条件がみたされる限りリストの要素を返し続ける。  
条件に合わない要素が見つかったらリストを返すのをやめる。例えば文字列の最初の単語をこんなふうに取れる。

```haskell
takeWhile (/=' ') "elephant know how to party"
```

10000より小さいすべての奇数の平方数の和を求めるために、まず (^2)関数を  
無限リスト[1..]をmapするところから始める。それから、奇数の要素だけ残るようにフィルタする。  
そのあとで、takeWhileを使って10000より小さい要素だけからなるリストを作る。  
最後に、そのリストの和を求める(sum関数を使う)。ワンライナーでいけるので関数の定義すら必要ない。

```haskell
ghci>sum (takeWhile (<10000) (filter odd (map (^2) [1..])))
166650
```

リスト内包表記を書くと次のようになる。

```haskell
sum (takeWhile (<10000) [m | m <- [n^2 | n <- [1..]], odd m])
```

つぎはコラッツ列というものを扱う問題。コラッツの数列は次のように定義されます。

+ 任意の自然数から開始する
+ 数が1ならば、終了
+ 数が偶数なら、2で割る
+ 数が奇数なら、3倍して1を足す
+ 新しい値でこのアルゴリズムを繰り返す

この定義にしたがうと、ある数の列ができる。  
この列は最初の数が何であっても最終的には１に到達すると予想されている。
例えば、13から始めると、13,40,20,10,5,16,8,4,2,1という列が得られる。
13から始めたコラッツ列の長さは10だとわかる。

ときたい問題はこれ。
「1から100までの数のウチ、長さ15以下のコラッツ列の開始数にあるものはいくつあるか？

最初のステップは数列を生成する関数を書くこと。

```haskell
chain :: Integer -> [Integer]
chain 1 = [1]
chain n
    | even n = n : chain (n 'div' 2)
    | odd n = n : chain (n * 3 + 1)
```

実際に問題に答える関数 numLongChains を書く。

```haskell
numLongChains :: Int
numLongChains = length (filter isLong (map chain [1..100]))
    where isLong xs = length xs > 15
```

[1..100]をchain関数でmapし、数列を要素とするリストを得る。  
その数列は、これもまたリストとしてリストとして表現している。  
それから、長さが15より大きいか調べる述語を使ってフィルタする。  
フィルタできたら、その結果のリストに数列がいくつあるかを数える。

##### map関数に複数の引数を与える

いままでmapするのに使っていた関数は、1引数のみを取る関数だけだった(`map (*2) [0..]` みたいな)。  
しかし、複数の引数を取る関数でmapすることも可能。例えば、`map (*) [0..]` のようなことが可能。  
関数、`*`は型(Num a) => a -> a -> a -> a を持ち、これがリストの各要素に適用される。

2引数の関数に1引数だけを与えると、1引数を取る関数が返される。  
故に、[0..]を * でmapしたら、1引数関数のリストが得られる。

```haskell
let listOfFuncs = map (*) [0..]
(listOfFuncs !! 4) 5
```

### ラムダ式

ラムダ式とは、1回だけ必要な関数を作るときに使う無名関数。  
通常、高階関数に渡す渡す関数を作るためだけに使われる。

##### ラムダ式を宣言する

+ バックスラッシュ(\)を書く
+ 引数をスペース区切りで書いていく
+ 続けて ->
+ 最後に関数の本体を書く

##### ラムダ式を使って numLongChains を実装する

```haskell
numLongChains :: Int
numLongChains = length (filter (\xs -> length xs > 15) (map chain [1..100])
```

ラムダ式は式なので関数に直接渡すことができる。  
カリー化と部分適用の動作がよくわかってないと必要ないところでラムダ式を使いがち。

普通の関数と同じように、ラムダ式でもパターンマッチができる。  
唯一異なるのは、1つの引数に対して複数のパターンを定義できない（同じ引数に対し [] と (x:xs) のパターンを作って合致するほうを選択するなど）

```haskell
zipWith (\a b -> (a * 30 + 3) / b) [5,4,3,2,1] [1,2,3,4,5]
```

※ラムダ式でパターンマッチに失敗するとランタイムエラーになる。

```haskell
flip' :: (a -> b -> c) -> b -> a -> c
flip' f = \x y -> f y x
```

flip で一番多い使い方は、引数として関数のみ、もしくは関数と引数を１つだけ渡し、生成された関数を map や zipWith に渡す方法。

```haskell
ghci>zipWith (flip (++)) ["love you", "love me"] ["i ", "you "]
["i love you","you love me"]
```

### 5.5 畳込み、見込みアリ

リストに対する再帰関数の多くは、ある共通のパターンに従っていた。  
それは「基底部は空のリストとし、x:xs パターンを使ってリストを先頭要素と残りのリストに分解する」というパターン。  
このパターンはとても頻繁に出てくるので、fold という畳込み関数経ちが用意されている。  

##### 畳み込みで使う関数

+ ２引数関数（２つの引数を取る関数。+ や div など）
+ 畳み込みに用いる値（アキュムレータと呼ばれる））の初期値。
+ それに畳み込むリストを受け取る

##### 畳み込みの挙動

リストは右からでも左からでも畳み込める。  
畳み込み関数は、アキュムレータとリストの先頭（あるいは最後)の要素を引数として与えられた２引数関数を呼び出す。  
その結果が、新しいアキュムレータになる。

新しいアキュムレータと新しく先頭（あるいは最後）になった要素を引数として再び２引数関数を呼出しまた新しいアキュムレータを作る。  
これをリスト全体を走査しきって単一のアキュムレータの値になるまで繰り返す。

##### foldl で左畳み込み

```haskell
sum' :: (Num a) => [a] -> a
sum' xs = foldl (\acc x -> acc + x) 0 xs
```

関数がカリー化されていることを踏まえると、この実装はもっと簡潔に書くことができる。

```haskell
sum'' :: (Num a) => [a] -> a
sum'' xs = foldl (+) 0
```

(\acc x -> acc + x) は (+) と同じかつ、foldl (+) 0 はリストを取る関数を返すので、引数の xs は省略できる。

##### foldr で右畳み込み

foldr はリストを右から順に処理する点を除いて左畳み込みと似ている。  
※リストは右からは走査できない。foldr はあくまでリストを左から走査するけれど、結果だけみると右から折りたたんだように見えるということ。

ひとつめの引数にリストの値、２つめにアキュムレータを渡す。  
これは直感的には、リストを右から畳み込むのでアキュムレータが右に位置するイメージ。

```haskell
ghci>:t foldl
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b
ghci>:t foldr
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
```

foldr を使って map' を実装する。

```haskell
map' :: (a -> b) -> [a] -> [b]
map' f xs = foldr (\x acc -> f x : acc) [] xs
```

左畳み込みを使って同様の実装もできなくはない

```haskell
map'' :: (a -> b) -> [a] -> [b]
map'' f xs = foldl (\acc x -> acc ++ [f x]) [] xs
```

++関数は、:よりもはるかに遅いので、リストから新しいリストを構築する際は普通は右畳み込みを使う。

##### foldl と foldr の大きな違い

右は無限リストに対しても適応可能、左はダメ。

##### 真偽値を返す関数の実装

指定された値が配列に含まれるかどうかを調べる関数elemの実装。

```haskell
elem' :: (Eq a) => a -> [a] -> Bool
elem' y ys = foldr (\x acc -> if x == y then True else acc) False ys
```

##### foldl1 と foldr1 関数

foldl1 と foldr1 は初期のアキュムレータを明示的に与える必要がない。  
その代わりにリストの先頭（あるいは末尾）の要素を初期アキュムレータとして使い、そこから畳み込みを始める。

maximum関数を実装してみる。

```haskell
maximum' :: (Ord a) => [a] -> a
maximum' = foldl1 max
```

max は２つの数値データを受け取って大きい方を返す。アキュムレータとリストの要素を受け取る。  
よって、畳み込みが完了すると配列の最大値が残る。

##### いくつかの畳み込みの例

```haskell
reverse1 :: [a] -> [a]
reverse1 = foldl (\acc x -> x : acc) []

reverse2 :: [a] -> [a]
reverse2 = foldl (flip (:)) []

product' :: (Num a) => [a] -> a
product' = foldl (*) 1

filter' :: (a -> Bool) -> [a] -> [a]
filter' p = folder (\x acc -> if p x then x : acc else acc) []

last' :: [a] -> a
last' = foldl1 (\_ x -> x)
```
