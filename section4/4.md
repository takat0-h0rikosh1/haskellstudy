# Hello 再帰

### 最高に最高!

Ord型クラスのインスタンスのリストを受け取って、その中で一番大きな値を返す関数 **maximum** を再帰処理で実装する。

```
maximum' :: (Ord a) => [a] -> a
maximum' [] = error "maximum of empty list!"
maximum' [x] = x
maximum' (x:xs) = max x (maximum' xs)
```

### さらにいくつかの再帰関数

##### replicate

第一引数にリストの要素数、第二引数にリストの要素を指定する。

```
replicate' :: Int -> a -> [a]
replicate' n x
    | n <= 0 = []
    | otherwise = x : replicate' (n -1) x
```

##### take

リストから指定された数の要素を返す。

```
take' :: Int -> [a] -> [a]
take' n _
    | n <= 0 = []
take' _ [] = []
take' n (x:xs) = x : take' (n - 1) xs
```

##### reverse

head と tail を逆にする作業を繰り返す。

```
reverse' :: [a] -> [a]
reverse' [] = []
reverse' (x:xs) = reverse' xs ++ [x]
```

##### repeat

指定された要素を無限に持つリストを作成する。

```
repeat' :: a -> [a]
repeat' x = x : repeat' x
```

##### zip

２つのリストを綴り合わせて返す。空のリストと綴り合わせると空リストが変える。

```
zip' :: [a] -> [b] -> [(a,b)]
zip' _ [] = []
zip' [] _ = []
zip' (x:xs) (y:ys) = (x, y) : zip' xs ys
```

##### ele

値とリストを受け取りその値がリストに含まれるかどうか調べる。

```
elem' :: (Eq a) => a -> [a] -> Bool
elem' a [] = False
elem' (x:xs)
    | a == x = True
    | otherwise = a `elem'` xs
```

### クイックソート

ソートしたいリストを [5,1,9,4,6,7,3] とする。  

1. 最初の要素の5を選択
2. 残りのリストか5以下の要素を左へ配置
3. 5より大きい要素を右に配置
4. [1,4,3,5,9,6,7] というリストが完成
5. [1,4,3] と [9,6,7] をそれぞれ同じ方法でソートする

この例における5をピボット(軸)と呼ばれる。  
ピボットに最初の要素を使う理由はパターンマッチで簡単に取り出せるから。

[1,4,3] をソートする

1. 最初の要素の1を選択
2. [] ++ [1] ++ [4,3] となる
3. [4,3] を同じようにソートする
4. [3] ++ [4] ++ [] となる
5. 最終的に [] ++ [1] ++ [3] ++ [4] ++ [] となってソートが完了する

5の右側も同じようにソートする

最終的には、[1,3,4,5,6,7,9] が完成する。

##### コード

クイックソートを実装する

```
quicksort :: (Ord a) => [a] -> [a]
quicksort [] = []
quicksort (x:xs) =
    let smallOrEqual = [a | a <- xs, a <= x]
        larger = [a | a <- xs, a > x]
    in quicksort smallOrEqual ++ [x] ++ quicksort larger
```

1. head と tail に分割
2. head の値よりも小さい要素の配列を作成(smallOrEqual)
3. head の値よりも大きい要素の配列を作成(larger)
4. head を smallOrEqual と larger をそれぞれ quicksort した結果で挟む。

### 再帰的に考える

再帰を書くには蹄跡がある。再帰に頼らない自明な解を持つ基底部から始める。  
それから、問題を一つもしくはそれ以上の部分問題を再帰的に解く。最後に最終的な解を部分問題の解から構築する。

再帰を使う際の蹄跡は、まず基底部を見極め、次に解くべき問題をより小さな部分問題へと分割する方法を考えること。

基底部と部分問題を正しく選べば、全体として何が起こるのかの詳細を考える必要はない。  
部分問題の解が正しいという保証をもとに、より大きな最終問題の解を構築すればよい。
