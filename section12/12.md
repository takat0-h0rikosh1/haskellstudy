# 第12章 モノイド

モノイドは値を二項演算子で結合できるような型を表す。

data キーワードを使って独自の代数データ型を作る方法、
type キーワードを使っての型に型シノニムを与える方法も見た。

はじめに newtype キーワードを使って既存の型から新たな型を作る方法を見ていく。
モノイドの世界にいると newtype キーワードをしょっちゅう使うことになるため。

### newtype

１つの型を取り、それをなにかにくるんで別のかたに見せかけるために作られた。

```haskell
newtype ZipList a = ZipList { getZipList :: [a] }
```

なぜ、常に data の代わりに newtype を使わないか。
その理由は newtype キーワードを使って既存の方から新しい型を作成するときには、
値コンストラクタは1種類しか作れず、その値コンストラクタが持てるフィールドも1つだけ、
という制約がある。

一方、dataキーワードを使えば、複数の値コンストラクタを持つデータ型を作れるし、
各コンストラクタには0以上の任意個数のフィールドをもたせることができる。

```haskell
data Profession = Fighter | Archer | Accountant
data Race = Human | Elf | Orc | Goblin
data PlayerCharacter = PlayerCharacter Race Profession
```

##### newtype を使って型クラスのインスタンスを作る

```haskell
newtype Pair b a = Pair { getPair :: (a, b) } deriving Show
instance Functor (Pair c) where
    fmap f (Pair (x, y)) = Pair (f x, y)

ghci>hoge = Pair (1, 1)
ghci>getPair $ fmap (+1) hoge
(2,1)
```

##### newtype と遅延評価

data で型クラス定義したときに関数のパターンマッチングで undefined が来ると例外が発生する

```haskell
ghci>undefined
*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err
  undefined, called at <interactive>:36:1 in interactive:Ghci19

ghci>head [3,4,5,undefined]
3

ghci>data CoolBool = CoolBool { getCoolBool :: Bool } deriving Show

ghci>:{
Prelude| helloMe :: CoolBool -> String
Prelude| helloMe (CoolBool _) = "hello"
Prelude| :}

ghci>helloMe undefined
"*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err
  undefined, called at <interactive>:45:9 in interactive:Ghci23
```

newtype で型クラス定義すれば例外は発生しない。

```haskell
newtype CoolBool = CoolBool { getCoolBool :: Bool } deriving Show

ghci>helloMe (CoolBool False)
"hello"
ghci>helloMe undefined
"hello"
```

newtype キーワードはコンストラクタを一つしか作れないと知っているので、helloMe関数の引数を評価することなく引数が
(CoolBool _) のパターンに合致すると判定できる。なぜなら newtype には値コンストラクタもフィールドも1つしかないのだから。

CharList を newtype で宣言。
もとの方が属していた型クラスを引き継がないので deriving して自動導出してやる。

```haskell
newtype CharList = CharList { getCharList :: [Char] } deriving (Eq, Show)
```

console で遊んだログ。

```haskell
ghci>newtype CharList = CharList { getCharList :: [Char] } deriving Show
ghci>CharList "aaa"
CharList {getCharList = "aaa"}
ghci>let cl = CharList "aaa"
ghci>getCharList cl
"aaa"
```

##### type, newtype, data の利用に関するまとめ

+ 型シグネチャを整理したいとか、型名が体を表すようにしたいだけならおそらく型シノニム( `type` )を使うのが良い
+ 既存のある型を型クラスインスタンスにしたくて、新しい型にくるむ方法を探している場合は `newtype` を使うのが良い。
+ 何か全く新しい型を作りたいのなら `data` を使うのが良い

### Monoid 大集合

Haskell の型クラスは、同じふるまいをする型達に共通のインターフェイスを提供するために使われている。
Eq, Ord, Functor, Applicative, ...etc

新しい型を作る人は「この型には何ができるだろう？どんな操作をサポートするだろう？」と考えて、
その型に欲しい機能をもとに、どの型クラスのインスタンスを実装するか決める。

`*` と `++` は共通の性質がある。

+ 関数は引数を２つ取る。
+ ２つの引数および返り値の値の型はすべて等しい
+ 2引数関数を施して相手を変えないような特殊な値が存在する。
