# 第12章 モノイド

モノイドは値を二項演算子で結合できるような型を表す。

data キーワードを使って独自の代数データ型を作る方法、
type キーワードを使っての型に型シノニムを与える方法も見た。

はじめに newtype キーワードを使って既存の型から新たな型を作る方法を見ていく。
モノイドの世界にいると newtype キーワードをしょっちゅう使うことになるため。

### newtype

１つの型を取り、それをなにかにくるんで別のかたに見せかけるために作られた。

```haskell
newtype ZipList a = ZipList { getZipList :: [a] }
```

なぜ、常に data の代わりに newtype を使わないか。
その理由は newtype キーワードを使って既存の方から新しい型を作成するときには、
値コンストラクタは1種類しか作れず、その値コンストラクタが持てるフィールドも1つだけ、
という制約がある。

一方、dataキーワードを使えば、複数の値コンストラクタを持つデータ型を作れるし、
各コンストラクタには0以上の任意個数のフィールドをもたせることができる。

```haskell
data Profession = Fighter | Archer | Accountant
data Race = Human | Elf | Orc | Goblin
data PlayerCharacter = PlayerCharacter Race Profession
```

##### newtype を使って型クラスのインスタンスを作る

```haskell
newtype Pair b a = Pair { getPair :: (a, b) } deriving Show
instance Functor (Pair c) where
    fmap f (Pair (x, y)) = Pair (f x, y)

ghci>hoge = Pair (1, 1)
ghci>getPair $ fmap (+1) hoge
(2,1)
```

##### newtype と遅延評価

data で型クラス定義したときに関数のパターンマッチングで undefined が来ると例外が発生する

```haskell
ghci>undefined
*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err
  undefined, called at <interactive>:36:1 in interactive:Ghci19

ghci>head [3,4,5,undefined]
3

ghci>data CoolBool = CoolBool { getCoolBool :: Bool } deriving Show

ghci>:{
Prelude| helloMe :: CoolBool -> String
Prelude| helloMe (CoolBool _) = "hello"
Prelude| :}

ghci>helloMe undefined
"*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err
  undefined, called at <interactive>:45:9 in interactive:Ghci23
```

newtype で型クラス定義すれば例外は発生しない。

```haskell
newtype CoolBool = CoolBool { getCoolBool :: Bool } deriving Show

ghci>helloMe (CoolBool False)
"hello"
ghci>helloMe undefined
"hello"
```

newtype キーワードはコンストラクタを一つしか作れないと知っているので、helloMe関数の引数を評価することなく引数が
(CoolBool _) のパターンに合致すると判定できる。なぜなら newtype には値コンストラクタもフィールドも1つしかないのだから。

CharList を newtype で宣言。
もとの方が属していた型クラスを引き継がないので deriving して自動導出してやる。

```haskell
newtype CharList = CharList { getCharList :: [Char] } deriving (Eq, Show)
```

console で遊んだログ。

```haskell
ghci>newtype CharList = CharList { getCharList :: [Char] } deriving Show
ghci>CharList "aaa"
CharList {getCharList = "aaa"}
ghci>let cl = CharList "aaa"
ghci>getCharList cl
"aaa"
```

##### type, newtype, data の利用に関するまとめ

+ 型シグネチャを整理したいとか、型名が体を表すようにしたいだけならおそらく型シノニム( `type` )を使うのが良い
+ 既存のある型を型クラスインスタンスにしたくて、新しい型にくるむ方法を探している場合は `newtype` を使うのが良い。
+ 何か全く新しい型を作りたいのなら `data` を使うのが良い

### Monoid 大集合

Haskell の型クラスは、同じふるまいをする型達に共通のインターフェイスを提供するために使われている。
Eq, Ord, Functor, Applicative, ...etc

新しい型を作る人は「この型には何ができるだろう？どんな操作をサポートするだろう？」と考えて、
その型に欲しい機能をもとに、どの型クラスのインスタンスを実装するか決める。

`*` と `++` は共通の性質がある。

+ 関数は引数を２つ取る。
+ ２つの引数および返り値の値の型はすべて等しい
+ 2引数関数を施して相手を変えないような特殊な値が存在する。

この性質を *結合的(associativity)* と呼ぶ。  
演算 `*` と `++` は結合的であるという。

結合的でない演算の例は `-` である。  
例えば `(5 - 3) - 4` と `5 - (3 - 4)` はことなる結果になる。

```haskell
ghci>(5 - 3) - 4
-2
ghci>5 - (3 - 4)
6
```

### Monoid型クラス

モノイドは、結合的な二項演算子(2引数関数)と、その演算に関する単位元からなる構造。
ある値がある演算の単位元であるとは、その値と何か他の値を引数にしてその演算を呼び出したとき、
返り値が常に他の値の方にひとしくなるということ。

1は `*` の単位元であり、[] は ++ の単位元です。  
Haskell の世界では他にも無数のモノイドがあるので、Mnoid型クラスが用意されている。
Mnoidの定義を見てみる。

```haskell
class Monoid m where
    mempty :: m
    mappend :: m -> m -> m
    mconcat :: [m] -> m
    mconcat = foldr mappend mempty
```

Monoid型クラスは Data.Monoid モジュールにて定義されている。

Monoidのインスタンスになれるのは具体型だけ。
型クラス定義に現れる m が型引数をとっていないことからそれがわかる。

この点で Monoind は、Functor や Applicative のような、1つの型引数を取る
型コンストラクタがインスタンスになる型とは異なる。

### Monoid#mempty

mempty は多相定数。  
Bounded の minBound みたいなもの。  
mempty は、その Monoind の単位元を表す。

##### Monoid#meppend

モノイド固有の二項演算。  
同じ型の引数を２つ取り、その型の別の値を返す。  

#### Monoid#mconcat

モノイドのリストを取って mappend を間に挟んだ式を作り単一の値を計算してくれる関数。  
mempty を初期値に取り、リストを mappend で右畳み込みしていくというデフォルト実装がついている。

ほとんどのモノイドに関してはこのデフォルト実装で十分なので、 mconcat に関してこれ以上深入りはしない。  
自分で Monoid 型クラスのインスタンスを作るときも、 mempty と mappend だけを実装すれば動く。  
インスタンスによっても、もっと効率的な mconcat の実装があるかもしれませんが、多くの場合はデフォルトの実装で何ら問題ない。

### モノイド則

so far...

- 単位元があること
- 結合的であること

Monoid のインスタンスを作る時は、必ず次の法則を満たしておかなければならない。

- mempty `mappend` x = x
- x `mappend` mempty = x
- (x `mappend` y) `mappend` z = x `mappend` (y `mappend` z)

はじめの２つは単位元として振る舞う。  
３つ目は結合的であることを示す。

### モノイドとの遭遇



# note

Bounded 型クラスのインスタンスは上限と下限を持ち、それぞれ minBound と maxBound 関数でしらべることができる。

```haskell
ghci>minBound :: Int
-9223372036854775808
ghci>minBound :: Char
'\NUL'
ghci>maxBound :: Char
'\1114111'
ghci>maxBound :: Bool
True
ghci>minBound :: Bool
False
```
