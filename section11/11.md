# 11章 ファンクターからアプリカティブファンクターへ

### 帰ってきたファンクター

ファンクターとは関数で写せるもの。
例えば、リスト、Maybe、木など。
ファンクターの型クラスメソッドは fmap のみ。

```haskell
fmap :: (a -> b) -> f a -> f b
```

「a を撮って b を返す関数」と a の入った箱を渡して、箱に入った b を返す。

型コンストラクタを Functor のインスタンスにするには、その型コンストラクタの種類(kind)は、
`* -> *` でなければならない。

つまりその型コンストラクタは型変数として一つだけ具体型を取る必要がある。

Either を Functor として扱うためには部分適応してやらなければならない。

`instance Functor Either where` は間違い。
`instance Functor (Either a) where` は正しいインスタンス宣言。

fmap は Either a に働くと考えれば次のような型になることがわかる。

`fmap :: (b -> c) -> Either a b -> Either a c`

Either a は不変であり、Either a のただ一つの変数の部分が変化している。

##### ファンクターとしてのI/Oアクション

IO String という型は、実行すると、外の世界へ出かけていって文字をとってきてそれを返してくれるようなI/Oアクションを表している。
取得結果は、do記法のなかで <- 構文をつかて名前に束縛できる。

IOはファンクターなので結果をIOの中に戻してやらなければならない。

IOの Functor インスタンスの定義を見てみる。
ある関数をある I/O アクションに fmap すると「元のI/Oと同じことをしつつ、その結果に指定した関数を適用して返す」I/Oアクションになってほしいわけである。

```haskell
instance Functor IO where
    fmap f action = do
        result <- action
        return (f result)
```

I/Oアクションを関数で写した結果もまた I/O アクションなので do 構文を使う。

1. 元々の I/O アクションを実行して結果を result と名付ける。
2. 次に return を行う。

return は「特に仕事を行わず、ただ何かを結果として提示する I/O アクション」を作る関数。

```haskell
main = do line <- getLine
          let line' = reverse line
          putStrLn $ "You said " ++ line' ++ " backwards!"
          putStrLn $ "Yes, you said " ++ line' ++ " backwards!"
```

ユーザーに文字列を入力してもらい、それを逆順に表示している。
`fmap` を使うと以下のように書ける。

```haskell
main = do line <- fmap reverse getLine
          putStrLn $ "You said " ++ line' ++ " backwards!"
          putStrLn $ "Yes, you said " ++ line' ++ " backwards!"
```

sample

```haskell
main = do
    r <- fmap (++"!") $ return "hello world"
    putStrLn r 
```

仮に fmap が IO に限定されていたら、 fmap の型は `fmap :: (a -> b) -> IO a -> IO b` になる。

もし自分のコードに何らかの関数にわたすためだけに I/O の結果に名前をつけている箇所があったら、fmap を使ってみてほしい。  
そのほうがきれいに書ける。

もしファンクターの中身を、1つでなく複数の関数を使って写したいなから、そのための関数をトップレベルで宣言してもいいし、
ラムダ式を使ってもいいが、一番いいのは関数合成。

```haskell
import Data.Char
import Data.List

main = do line <- fmap (intersperse '-' . reverse . map toUpper) getLine
          putStrLn line
          
-- 以下のように書いても同じ
-- (\xs -> intersperse '-' (reverse (map toUpper xs)))
```

##### ファンクターとしての関数

関数の型を表す r -> a は (->) r a と書き換えることができる。
2 + 3 を (+) 2 3 と表現できるのと同様。

関数の型を (->) r a と表現するとき、関数 (->) には、2つの型引数を取る型コンストラクタという新しい姿見えてくる。
Either と同様。


