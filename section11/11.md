# 11章 ファンクターからアプリカティブファンクターへ

### 帰ってきたファンクター

ファンクターとは関数で写せるもの。
例えば、リスト、Maybe、木など。
ファンクターの型クラスメソッドは fmap のみ。

```haskell
fmap :: (a -> b) -> f a -> f b
```

「a を撮って b を返す関数」と a の入った箱を渡して、箱に入った b を返す。

型コンストラクタを Functor のインスタンスにするには、その型コンストラクタの種類(kind)は、
`* -> *` でなければならない。

つまりその型コンストラクタは型変数として一つだけ具体型を取る必要がある。

Either を Functor として扱うためには部分適応してやらなければならない。

`instance Functor Either where` は間違い。
`instance Functor (Either a) where` は正しいインスタンス宣言。

fmap は Either a に働くと考えれば次のような型になることがわかる。

`fmap :: (b -> c) -> Either a b -> Either a c`

Either a は不変であり、Either a のただ一つの変数の部分が変化している。

##### ファンクターとしてのI/Oアクション

IO String という型は、実行すると、外の世界へ出かけていって文字をとってきてそれを返してくれるようなI/Oアクションを表している。
取得結果は、do記法のなかで <- 構文をつかて名前に束縛できる。

IOはファンクターなので結果をIOの中に戻してやらなければならない。

IOの Functor インスタンスの定義を見てみる。
ある関数をある I/O アクションに fmap すると「元のI/Oと同じことをしつつ、その結果に指定した関数を適用して返す」I/Oアクションになってほしいわけである。

```haskell
instance Functor IO where
    fmap f action = do
        result <- action
        return (f result)
```

I/Oアクションを関数で写した結果もまた I/O アクションなので do 構文を使う。

1. 元々の I/O アクションを実行して結果を result と名付ける。
2. 次に return を行う。

return は「特に仕事を行わず、ただ何かを結果として提示する I/O アクション」を作る関数。

```haskell
main = do line <- getLine
          let line' = reverse line
          putStrLn $ "You said " ++ line' ++ " backwards!"
          putStrLn $ "Yes, you said " ++ line' ++ " backwards!"
```

ユーザーに文字列を入力してもらい、それを逆順に表示している。
`fmap` を使うと以下のように書ける。

```haskell
main = do line <- fmap reverse getLine
          putStrLn $ "You said " ++ line' ++ " backwards!"
          putStrLn $ "Yes, you said " ++ line' ++ " backwards!"
```

sample

```haskell
main = do
    r <- fmap (++"!") $ return "hello world"
    putStrLn r 
```

仮に fmap が IO に限定されていたら、 fmap の型は `fmap :: (a -> b) -> IO a -> IO b` になる。

もし自分のコードに何らかの関数にわたすためだけに I/O の結果に名前をつけている箇所があったら、fmap を使ってみてほしい。  
そのほうがきれいに書ける。

もしファンクターの中身を、1つでなく複数の関数を使って写したいなから、そのための関数をトップレベルで宣言してもいいし、
ラムダ式を使ってもいいが、一番いいのは関数合成。

```haskell
import Data.Char
import Data.List

main = do line <- fmap (intersperse '-' . reverse . map toUpper) getLine
          putStrLn line
          
-- 以下のように書いても同じ
-- (\xs -> intersperse '-' (reverse (map toUpper xs)))
```

##### ファンクターとしての関数

関数の型を表す r -> a は (->) r a と書き換えることができる。
2 + 3 を (+) 2 3 と表現できるのと同様。

関数の型を (->) r a と表現するとき、関数 (->) には、2つの型引数を取る型コンストラクタという新しい姿見えてくる。
Either と同様。

### ファンクター則

##### 第一法則

「id でファンクターを写した場合、ファンクター値が変化してはいけない」というもの。  
id は恒等写像、引数をそのまま返す関数。

```haskell
ghci>id 1
1
ghci>fmap id (Just 3)
Just 3
ghci>fmap id [1..5]
[1,2,3,4,5]
ghci>fmap id []
[]
ghci>fmap id Nothing
Nothing
```

##### 第二法則

関数合成と写す操作との間の関係。  
「f と g の合成関数でファンクター値を写したもの」と、  
「まず g、次に f でファンクター値を写したもの」が等しいことを要求する。

fmap (f . g) = fmap f . fmap g ということ

言い換えるとすべてのファンクター値 x に対し、

fmap (f .g) x = fmap f . (fmap g x) が成り立つべしということ。

##### 法則を破る

Functor なのに、則を満たしてない病的な例を考える。

```haskell
data CMaybe a = CNothing | CJust Int a deriving (Show)
```

C は 「counter」のつもり
CMaybe a は、Maybe a によく似たデータ型だが、Just 部分のフィールドが一つではなく2つある。
CJust の1つ目のフィールドは常に Int 型で、これが何らかのカウンタになる。
2つ目のフィールドの型 a は型引数で、a の型が何になるかわ CMaybe a をどんな具体型いしたいかによってきまる。

```haskell
ghci>CNothing
CNothing
ghci>CJust 0 "hahaha"
CJust 0 "hahaha"
ghci>:t CNothing
CNothing :: CMaybe a
ghci>:t CJust 0 "haha"
CJust 0 "haha" :: CMaybe [Char]
ghci>CJust 100 [1,2,3]
CJust 100 [1,2,3]
```

```haskell
instance Functor CMaybe where
    fmap f CNothing = CNothing
    fmap f (CJust counter x) = CJust (counter+1) (f x)
```

```haskell
ghci>fmap id (CJust 0 "haha")
CJust 1 "haha"
ghci>id (CJust 0 "haha")
CJust 0 "haha"
```

id ファンクターを写した結果と単に id をファンクター値に適用した結果とが等しくなければならない。  
よって、CMaybe はこの性質を満たさない。

### アプリカティブファンクターを使おう

```haskell
ghci>let a = fmap (*) [1,2,3,4]
ghci>:t a
a :: Num a => [a -> a]
ghci>fmap (\f -> f 9) a
[9,18,27,36]
ghci>fmap ($9) a
[9,18,27,36]
```

### Applicative ちゃんと仲良くしてあげてね！

型クラス Applicative は、2つの関数 pure と <*> を定義している。  
どちらもデフォルト実装は与えられてないので、ある型を Applicative のインスタンスにしたかったら、
両方の定義を与える必要がある。クラス定義はこんな感じ。

```haskell
class (Functor f) => Applicative f where
    pure :: a -> f a
    (<*>) :: f (a -> b) -> f a ->  f b
```

##### Maybe はアプリカティブファンクター

```haskell
ghci>Just (+3) <*> Just 9
Just 12
ghci>pure (+3) <*> Just 10
Just 13
ghci>Just (++"hahaha") <*> Nothing
Nothing
ghci>Nothing <*> Just "woot"
Nothing
```

functor は一旦関数で写したら、ファンクターの中に入ってしまった関数適用の結果をファンクターの外に取り出す一般的な方法はない。
一方アプリカティブファンクターなら、1つの関数で複数のファンクターを続けざまに写せる。

##### アプリカティブスタイル

<*> を連続して使う。

```haskell
ghci>pure (+) <*> Just 3 <*> Just 5
Just 8
ghci>pure (+) <*> Just 3 <*> Nothing
Nothing
ghci>pure (+) <*> Nothing <*> Just 5
Nothing
```

+ をアプリカティブ値の中に入れ、さらに `<*>` を使って2つの引数に適応しているが、どちらもアプリカティブ値。
`<*>` は左結合なので、

```haskell
pure (+) <*> Just 3 <*> Just 5

-- この式は、以下と同じ
(pure (+) <*> Just 3) <*> Just 5
```

- まず、pure (+) をして Just (+) を作る。
- 次に Just (+) <*> Just 3 が評価され、結果が Just (3+) となる。 -> 部分適用が起きてる
- 最後に Just (3+) <*> Just 5 が実行されて、結果が Just 8 となる。

アプリカティブファンクターとアプリカティブスタイル、
`pure f <*> x <*> y <*> ...` を使えばもともとアプリカティブなんて知らずに書かれた普通の関数にも、
アプリカティブ値の引数を与えることができる。

`pure f <*> x` は `fmap f x` と等しい。これはアプリカティブ則の一つ。

pure は値をデフォルトの文脈の中に入れる。  
ある関数をデフォルトの文脈の中に入れ、また取り出して別のアプリカティブファンクターの中の値に適応する。
この操作は、単に別の関数でアプリカティブファンクターを写すのと同じこと。

そこで、`pure f <*> x <*> y <*> ...` と書く代わりに、`f map f x <*> y <*> ...` と書くことができる。
このパターンはしょっちゅう使うので、 Control.Applicative は fmap と等価な中置演算子 `<$>` をエクスポートしている。
`<$>` の定義は以下。

```haskell
(<$>) :: (Functor f) => (a -> b) f a -> f b
f <$> x = fmap f x
```

関数 f を3つのアプリカティブ値の引数に適用したければ、 `f <$> x <*> y <*> z` と書くことができる。
例えば Just "johntra" と Just "volta" を結合して１つの Maybe String 型の値を作りたいとする。
以下のように書くことができる。

```haskell
ghci>(++) <$> Just "johntra" <*> Just "volta"
Just "johntravolta"
```

普通の関数をアプリカティブファンクターの関数として使うには、`<$>` と `<*>` を散りばめるだけ。
すると関数は、アプリカティブ値を取ってアプリカティブ値を返すようになる。

##### リスト

リストもアプリカティブファンクター。
[] のアプリカティブインスタンス宣言。

```haskell
instance Applicative [] where
    pure x = [x]
    fs <*> xs = [f x | f <- fs, x <- xs]
 ```
 
 
