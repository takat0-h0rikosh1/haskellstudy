# 11章 ファンクターからアプリカティブファンクターへ

### 帰ってきたファンクター

ファンクターとは関数で写せるもの。
例えば、リスト、Maybe、木など。
ファンクターの型クラスメソッドは fmap のみ。

```haskell
fmap :: (a -> b) -> f a -> f b
```

「a を撮って b を返す関数」と a の入った箱を渡して、箱に入った b を返す。

型コンストラクタを Functor のインスタンスにするには、その型コンストラクタの種類(kind)は、
`* -> *` でなければならない。

つまりその型コンストラクタは型変数として一つだけ具体型を取る必要がある。

Either を Functor として扱うためには部分適応してやらなければならない。

`instance Functor Either where` は間違い。
`instance Functor (Either a) where` は正しいインスタンス宣言。

fmap は Either a に働くと考えれば次のような型になることがわかる。

`fmap :: (b -> c) -> Either a b -> Either a c`

Either a は不変であり、Either a のただ一つの変数の部分が変化している。

##### ファンクターとしてのI/Oアクション

IO String という型は、実行すると、外の世界へ出かけていって文字をとってきてそれを返してくれるようなI/Oアクションを表している。
取得結果は、do記法のなかで <- 構文をつかて名前に束縛できる。

IOはファンクターなので結果をIOの中に戻してやらなければならない。

IOの Functor インスタンスの定義を見てみる。
ある関数をある I/O アクションに fmap すると「元のI/Oと同じことをしつつ、その結果に指定した関数を適用して返す」I/Oアクションになってほしいわけである。

```haskell
instance Functor IO where
    fmap f action = do
        result <- action
        return (f result)
```

I/Oアクションを関数で写した結果もまた I/O アクションなので do 構文を使う。

1. 元々の I/O アクションを実行して結果を result と名付ける。
2. 次に return を行う。

return は「特に仕事を行わず、ただ何かを結果として提示する I/O アクション」を作る関数。

```haskell
main = do line <- getLine
          let line' = reverse line
          putStrLn $ "You said " ++ line' ++ " backwards!"
          putStrLn $ "Yes, you said " ++ line' ++ " backwards!"
```

ユーザーに文字列を入力してもらい、それを逆順に表示している。
`fmap` を使うと以下のように書ける。

```haskell
main = do line <- fmap reverse getLine
          putStrLn $ "You said " ++ line' ++ " backwards!"
          putStrLn $ "Yes, you said " ++ line' ++ " backwards!"
```

sample

```haskell
main = do
    r <- fmap (++"!") $ return "hello world"
    putStrLn r 
```

仮に fmap が IO に限定されていたら、 fmap の型は `fmap :: (a -> b) -> IO a -> IO b` になる。

もし自分のコードに何らかの関数にわたすためだけに I/O の結果に名前をつけている箇所があったら、fmap を使ってみてほしい。  
そのほうがきれいに書ける。

もしファンクターの中身を、1つでなく複数の関数を使って写したいなから、そのための関数をトップレベルで宣言してもいいし、
ラムダ式を使ってもいいが、一番いいのは関数合成。

```haskell
import Data.Char
import Data.List

main = do line <- fmap (intersperse '-' . reverse . map toUpper) getLine
          putStrLn line
          
-- 以下のように書いても同じ
-- (\xs -> intersperse '-' (reverse (map toUpper xs)))
```

##### ファンクターとしての関数

関数の型を表す r -> a は (->) r a と書き換えることができる。
2 + 3 を (+) 2 3 と表現できるのと同様。

関数の型を (->) r a と表現するとき、関数 (->) には、2つの型引数を取る型コンストラクタという新しい姿見えてくる。
Either と同様。

### ファンクター則

##### 第一法則

「id でファンクターを写した場合、ファンクター値が変化してはいけない」というもの。  
id は恒等写像、引数をそのまま返す関数。

```haskell
ghci>id 1
1
ghci>fmap id (Just 3)
Just 3
ghci>fmap id [1..5]
[1,2,3,4,5]
ghci>fmap id []
[]
ghci>fmap id Nothing
Nothing
```

##### 第二法則

関数合成と写す操作との間の関係。  
「f と g の合成関数でファンクター値を写したもの」と、  
「まず g、次に f でファンクター値を写したもの」が等しいことを要求する。

fmap (f . g) = fmap f . fmap g ということ

言い換えるとすべてのファンクター値 x に対し、

fmap (f .g) x = fmap f . (fmap g x) が成り立つべしということ。

##### 法則を破る

Functor なのに、則を満たしてない病的な例を考える。

```haskell
data CMaybe a = CNothing | CJust Int a deriving (Show)
```

C は 「counter」のつもり
CMaybe a は、Maybe a によく似たデータ型だが、Just 部分のフィールドが一つではなく2つある。
CJust の1つ目のフィールドは常に Int 型で、これが何らかのカウンタになる。
2つ目のフィールドの型 a は型引数で、a の型が何になるかわ CMaybe a をどんな具体型いしたいかによってきまる。

```haskell
ghci>CNothing
CNothing
ghci>CJust 0 "hahaha"
CJust 0 "hahaha"
ghci>:t CNothing
CNothing :: CMaybe a
ghci>:t CJust 0 "haha"
CJust 0 "haha" :: CMaybe [Char]
ghci>CJust 100 [1,2,3]
CJust 100 [1,2,3]
```

```haskell
instance Functor CMaybe where
    fmap f CNothing = CNothing
    fmap f (CJust counter x) = CJust (counter+1) (f x)
```

```haskell
ghci>fmap id (CJust 0 "haha")
CJust 1 "haha"
ghci>id (CJust 0 "haha")
CJust 0 "haha"
```

id ファンクターを写した結果と単に id をファンクター値に適用した結果とが等しくなければならない。  
よって、CMaybe はこの性質を満たさない。

### アプリカティブファンクターを使おう

```haskell
ghci>let a = fmap (*) [1,2,3,4]
ghci>:t a
a :: Num a => [a -> a]
ghci>fmap (\f -> f 9) a
[9,18,27,36]
ghci>fmap ($9) a
[9,18,27,36]
```

### Applicative ちゃんと仲良くしてあげてね！

型クラス Applicative は、2つの関数 pure と <*> を定義している。  
どちらもデフォルト実装は与えられてないので、ある型を Applicative のインスタンスにしたかったら、
両方の定義を与える必要がある。クラス定義はこんな感じ。

```haskell
class (Functor f) => Applicative f where
    pure :: a -> f a
    (<*>) :: f (a -> b) -> f a ->  f b
```