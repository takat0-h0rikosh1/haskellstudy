# 高階関数

引数として関数を受け取る関数。これを高階関数という。

### 5.1 カリー化関数

複数の引数を受け取れるように見えたのはカリー化された関数であるから。  
カリー化関数が呼ばれると、その次の引数を受け取る関数を返す。その繰り返し。

max 関数の型

```
ghci>:t max
max :: Ord a => a -> a -> a
```

`->` を型シグネチャに含むものはすべて関数。
つまり左側にあるものを引数に取り、右側にあるものを型とする値を返す。

関数を本来より少ない引数で呼び出したときに部分適用された関数が得られる。  
部分適用 → 本来より少ない引数で呼び出すこと。

部分適用を使うと関数をその場でお手軽に作り出して、それを他の関数に渡せる。

```
multThree :: Int -> Int -> Int -> Int
multThree :: x y z = x * y * z
```

multiThree 3 5 9 あるいは ((multiThree 3) 5) 9 を呼び出すと何がおこるのか。

1. multiThree が 3 に適用され、「引数を１つ取って関数を返す関数」が返る。
2. 上記の関数が 5 に適用され、「引数を取って 3 と 5 を掛けた数を返す関数」ができる。
3, 上記の関数が 9 に適用され、135 が最終的な結果となる。

関数は何か材料を受け取って何かを作り出す小さな工場だと考えられる。  
`multiThree` の型は次のようにも書ける。

multiThree :: Int -> (Int -> (Int -> Int))

->の前にあるのは関数が受け取る値の型。後ろにあるのは返り値の型。
なので、この関数は Int 型の値を受け取り、(Int -> (Int -> Int)) という型を返す。  
最後にこの関数は Int 型の値を受け取り、Int型の値を返す。

本来より少ない引数で関数を呼び出すことによって新しい関数を作る例を見ていく。

```
ghci>let multTwoWithNine = multThree 9
ghci>multTwoWithNine 2 3
```

上記の例では、式 `multThree 9` の結果は2引数の関数になる。  
この関数に `multTwoWithNine` という名前を付けている。
`multThree 9` は2つ引数を取る関数のためである。

Int を引数に取って100と比較する関数を作る。

```
compareWithHundred :: Int -> Ordering
compareWithHundred x = compare 100 x
```

100は99より大きいのでGTとなる。  
答は「数を引数に取り100と比較する関数」。  
以下の定義と等価。

```
compareWithHundred :: Int -> Ordering
compareWithHundred = compare 100
```

##### セクション

中置関数に対してセクションという機能を使って部分適用することができる。  
中置関数をセクションするには片側だけに値を置いて括弧で囲むだけ。  
これで引数を一つ、値を置かなかった側に取る関数ができる。

```haskell
divideByTen :: (Floating a) => a -> a
divideByTen = (/10)
```

以下は、それぞれ等価となる。

```haskell
ghci>divideByTen 200
20.0
ghci>200 /10
20.0
ghci>(/10) 200
20.0
```

セクションで唯一気をつけなければならないのは、- (負の数、マイナス)演算子と同時につかうとき。  
(-4)は、セクションの定義から考えると、数を受け取ってそれから4を引く関数になると思われる。  
しかし(-4)は、利便性のために、マイナス4を意味することになっている。なので、引数から4を引き算する関数を作りたいときには、  
`substract` 関数を `(substract 4)` のように部分適用する。

##### 関数を表示する

関数そのものをターミナルに表示する。  
`multThree 3 4` をそのままGHCiに打ち込んでみる。

```haskell
ghci>multThree 3 4

<interactive>:14:1: error:
    • No instance for (Show (Int -> Int)) arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
```

GHCiは、この式が a -> a の型の関数を生成しあけど、それをどうやって画面に表示したらいいか分からないといっている。  
関数は Show 型クラスのインスタンスではないので、いい感じに関数を表現する文字列がえられない。  

これは、例えば 1 + 1 のような式を入力した場合とはことなる。  
この場合、GHCiは式の結果として2を計算し、それから2に対して show を読んで、数のテキスト表現を得る。  
2のテキスト表現は単に文字列 "2" なので、これがスクリーンに表示される。

### 高階実演

すでに説明したとおり、Haskell では関数は別の関数を引数として受け取ることも、返り値として関数を返すこともできる。  
このコンセプトの実演として、関数を受け取り、それを2回適用する関数を書いてみる。

```haskell
applyTwice :: (a -> a) -> a -> a
applyTwice f x = f (f x)
```

`(a -> a)` は 「「1つの引数を取り、同じかたの値を返す関数」だということを示している。  
２つ目の引数は何かのa型の値で、返り値もa型。aは何の型、つまりIntでもStringでも、あるいはもっとほかの型でもかまわない。  
しかし、すべてのaは同じ型でなければならにことに注意。

applyTwice は第一引数の関数を第二引数の値に対し二度適用する関数。

```haskell
ghci>applyTwice (+3) 10
16
ghci>applyTwice (++ " HAHA") "HEY"
"HEY HAHA HAHA"
ghci>applyTwice (multThree 2 2) 9
144
ghci>applyTwice (3:) [1]
[3,3,1]
```

部分適用のすごさと実用性が歴然とわかる。  

##### zipWith を実装する

*zipWith* を実装する。*zipWith* は関数と2つのリストを引数にとり、2つのリストの各要素にその関数を適用することで、  
2つのリストを1つに結合する。

```haskell
zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith' _ [] _ = []
zipWith' _ _ [] = []
zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys
```

+ １つ目の引数は、引数を２つ取り値を１つ返す関数。
+ ２つ目と３つ目の引数はリスト。
+ 最初のリストはa型の値のリストでなければならない。
   + なぜならリストの結合に使う関数が第一引数としてaという型をとるため。
+ ２番目のリストは同様の理由でb型でなければならない。
+ 結果はc型の要素のリストとなる。

```haskell
ghci>zipWith' (+) [4,2,5,6] [ 2,6,2,3]
[6,8,7,9]
ghci>zipWith' max [6,3,2,1] [7,3,1,5]
[7,3,2,5]
ghci>zipWith
zipWith   zipWith'  zipWith3
ghci>zipWith' (++) ["foo", "bar", "baz"] ["fighters", "hoppers", "aldrin"]
["foofighters","barhoppers","bazaldrin"]
ghci>zipWith' (*) (replicate 5 2) [1..]
[2,4,6,8,10]
ghci>zipWith' (zipWith' (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]]
[[3,4,6],[9,20,30],[10,12,12]]
```

##### flip を実装する

flip関数は関数を引数に取り、元の関数に似ているけど最初の２つの引数が入れ替わった関数を返す。

```haskell
flip' :: (a -> b -> c) -> (b -> a -> c)
flip' f = g
    where g x y = f y x
```

型宣言からflip'は「a型とb型の値を引数に取る関数」を引数に取り、  
「b型とa型の値を引数に取る関数」を返す。

なお、関数はデフォルトでカリー化されているので、２つ目の括弧は厳密には必要ない。矢印 *->* は、  
デフォルトで右結合なので以下の型定義はすべて同じ。 

+ **(a -> b -> c) -> (b -> a -> c)**
+ **(a -> b -> c) -> (b -> (a -> c))**
+ **(a -> b -> c) -> b -> a -> c**

上のコードでは、*g x y = f y x* と書いたが、*f y x = g x y* もまた成り立つ。  
これを踏まえると flip' の実装をもっと簡潔にできる。

```haskell
flip'' :: (a -> b -> c) -> (b -> a -> c)
flip'' f y x = g x y
```

この新しいバージョンのflip''は、関数がカリー化されていることをうまく使っている。  
*flip'' f* を引数yとxなしで呼び出すと、2つの引数を取る、引数の入れ替わったfが返る。

flipされた関数を、また別の関数にわたすこともよくある。  
そんな場合でも、関数が完全に適用されたらどんな結果になるのかをよく考えてみたり。  
結果を書き下してみたりすれば、高階関数を作るときにカリー化がうまく利用できる。  

```haskell
ghci>zip [1,2,3,4,5] "hello"
[(1,'h'),(2,'e'),(3,'l'),(4,'l'),(5,'o')]
ghci>flip'' zip [1,2,3,4,5] "hello"
[('h',1),('e',2),('l',3),('l',4),('o',5)]
ghci>zipWith div [2,2..] [10,8,6,4,2]
[0,0,0,0,1]
ghci>zipWith (flip'' div) [2,2..] [10,8,6,4,2]
[5,4,3,2,1]
```

### 関数プログラマの道具箱

関数プログラマは数や文字や他の型のデータのあつまりを受け取り、その集合を変換して結果を得たいもの。
この節では、複数の値を使って仕事をするときに便利な関数を見ていくことにする。

##### map関数

map関数は関数とリストを受け取って、その関数をリストのすべての要素に適用して新しいリストを生成する。

```haskell
map :: (a -> b) -> [a] -> [b]
map _ [] = []
map f (x:xs) = f x : map f xs
```

mapはいろいろな使い方ができる多彩な関数。

```haskell
ghci>map (+3) [1,5,3,1,6]
[4,8,6,4,9]
ghci>map (++ "!") ["BIFF", "BANG", "POW"]
["BIFF!","BANG!","POW!"]
ghci>map (map (^2)) [[1,2],[3,4,5,6],[7,8]]
[[1,4],[9,16,25,36],[49,64]]
ghci>map fst [(1,2),(3,5),(6,3),(2,6),(2,5)]
[1,3,6,2,2]
```

map関数と同様のことがリスト内包表記を使って同じことができる。  
下記のふたつの式は同等となる。

```haskell
map (+3) [1,5,3,1,6]
[x+3 | x <- [1,5,3,1,6]]
```

mapのほうが読みやすい。

##### filter関数

filter関数は述語とリストを受け取って、そのリストの要素のうち、述語をみたすもののみからなるリストを返す。
※述語とは、何がtrueで何がfalseかを言う関数。つまり真理値を返す関数。

```haskell
filter :: (a -> Bool) -> [a] -> [b]
filter _ [] = []
filter p (x:xs)
    | p x = x : filter p xs
    | otherwise = filter p xs
```

filterの例

```haskell
ghci>let notNull x = not (null x) in filter notNull [[1,2,3],[],[3,4,5],[2,2],[],[],[]]
[[1,2,3],[3,4,5],[2,2]]
ghci>:t not
not :: Bool -> Bool
ghci>filter (`elem` ['a'..'z']) "u LaUgH aT mE BeCaUsE I aM diFfeRent"
"uagameasadifeent"
ghci>filter (`elem` ['A'..'Z']) "i LAuGh at you bEcause u R all the same"
"LAGER"
```

これらもmapのときと同様にリスト内包表記と述語を使って書ける。
リスト内包表記で複数の述語を指定するようなケースをfilterで書くときには、filterを何度か適用するか、
述語を論理関数 && でつないで指定する。

```haskell
ghci>filter (<15) (filter even [1..20])
[2,4,6,8,10,12,14]
```

この例では、リスト [1..20] を受け取り、偶数だけ残すようにフィルタしている。そのあと、リストを filter (<15) に渡し、15以上の数を取り除いている。リスト内包表記ならこうなる。

```haskell
[x | x <- [1..20], x < 15, even x]
```

以前、実装した quicksort 関数はは filter を使えばもっと読みやすくなる。

```haskell
quicksort :: (Ord a) => [a] -> [b]
quicksort [] = []
quicksort (x:xs) =
    let smallerOrEqual = filter (<= x) xs
        larger = filter (> x) xs
    in  quicksort smallerOrEqual ++ [x] ++ quicksort larger
```

##### mapとfilterのさらなる例

ex). 10万以下の数のうち3829で割り切れる最大の数を探す。  
それには、解があるとわかっている範囲から解になり得る集合をフィルタするだけ。

```haskell
largestDivisible :: Integer
largestDivisible = head (filter p [100000,99999..])
    where p x = x `mod` 3829 == 0
```

ex). 10000 より小さいすべての奇数の平方数の和をもとめる。

これには takeWhile という関数を使う。この関数は述語とリストを受け取り、  
リストの先頭から始めて述語の条件がみたされる限りリストの要素を返し続ける。  
条件に合わない要素が見つかったらリストを返すのをやめる。例えば文字列の最初の単語をこんなふうに取れる。

```haskell
takeWhile (/=' ') "elephant know how to party"
```

10000より小さいすべての奇数の平方数の和を求めるために、まず (^2)関数を  
無限リスト[1..]をmapするところから始める。それから、奇数の要素だけ残るようにフィルタする。  
そのあとで、takeWhileを使って10000より小さい要素だけからなるリストを作る。  
最後に、そのリストの和を求める(sum関数を使う)。ワンライナーでいけるので関数の定義すら必要ない。

```haskell
ghci>sum (takeWhile (<10000) (filter odd (map (^2) [1..])))
166650
```

リスト内包表記を書くと次のようになる。

```haskell
sum (takeWhile (<10000) [m | m <- [n^2 | n <- [1..]], odd m])
```

つぎはコラッツ列というものを扱う問題。コラッツの数列は次のように定義されます。

+ 任意の自然数から開始する
+ 数が1ならば、終了
+ 数が偶数なら、2で割る
+ 数が奇数なら、3倍して1を足す
+ 新しい値でこのアルゴリズムを繰り返す

この定義にしたがうと、ある数の列ができる。  
この列は最初の数が何であっても最終的には１に到達すると予想されている。
例えば、13から始めると、13,40,20,10,5,16,8,4,2,1という列が得られる。
13から始めたコラッツ列の長さは10だとわかる。

ときたい問題はこれ。
「1から100までの数のウチ、長さ15以下のコラッツ列の開始数にあるものはいくつあるか？

最初のステップは数列を生成する関数を書くこと。

```haskell
chain :: Integer -> [Integer]
chain 1 = [1]
chain n
    | even n = n : chain (n 'div' 2)
    | odd n = n : chain (n * 3 + 1)
```

実際に問題に答える関数 numLongChains を書く。

```haskell
numLongChains :: Int
numLongChains = length (filter isLong (map chain [1..100]))
    where isLong xs = length xs > 15
```

[1..100]をchain関数でmapし、数列を要素とするリストを得る。  
その数列は、これもまたリストとしてリストとして表現している。  
それから、長さが15より大きいか調べる述語を使ってフィルタする。  
フィルタできたら、その結果のリストに数列がいくつあるかを数える。

##### map関数に複数の引数を与える

いままでmapするのに使っていた関数は、1引数のみを取る関数だけだった(`map (*2) [0..]` みたいな)。  
しかし、複数の引数を取る関数でmapすることも可能。例えば、`map (*) [0..]` のようなことが可能。  
関数、`*`は型(Num a) => a -> a -> a -> a を持ち、これがリストの各要素に適用される。

2引数の関数に1引数だけを与えると、1引数を取る関数が返される。  
故に、[0..]を * でmapしたら、1引数関数のリストが得られる。

```haskell
let listOfFuncs = map (*) [0..]
(listOfFuncs !! 4) 5
```

### ラムダ式

ラムダ式とは、1回だけ必要な関数を作るときに使う無名関数。  
通常、高階関数に渡す渡す関数を作るためだけに使われる。

##### ラムダ式を宣言する

+ バックスラッシュ(\)を書く
+ 引数をスペース区切りで書いていく
+ 続けて ->
+ 最後に関数の本体を書く

##### ラムダ式を使って numLongChains を実装する

```haskell
numLongChains :: Int
numLongChains = length (filter (\xs -> length xs > 15) (map chain [1..100])
```

ラムダ式は式なので関数に直接渡すことができる。  
カリー化と部分適用の動作がよくわかってないと必要ないところでラムダ式を使いがち。

普通の関数と同じように、ラムダ式でもパターンマッチができる。  
唯一異なるのは、1つの引数に対して複数のパターンを定義できない（同じ引数に対し [] と (x:xs) のパターンを作って合致するほうを選択するなど）

```haskell
zipWith (\a b -> (a * 30 + 3) / b) [5,4,3,2,1] [1,2,3,4,5]
```

※ラムダ式でパターンマッチに失敗するとランタイムエラーになる。

```haskell
flip' :: (a -> b -> c) -> b -> a -> c
flip' f = \x y -> f y x
```

flip で一番多い使い方は、引数として関数のみ、もしくは関数と引数を１つだけ渡し、生成された関数を map や zipWith に渡す方法。

```haskell
ghci>zipWith (flip (++)) ["love you", "love me"] ["i ", "you "]
["i love you","you love me"]
```

### 5.5 畳込み、見込みアリ

リストに対する再帰関数の多くは、ある共通のパターンに従っていた。  
それは「基底部は空のリストとし、x:xs パターンを使ってリストを先頭要素と残りのリストに分解する」というパターン。  
このパターンはとても頻繁に出てくるので、fold という畳込み関数経ちが用意されている。  

##### 畳み込みで使う関数

+ ２引数関数（２つの引数を取る関数。+ や div など）
+ 畳み込みに用いる値（アキュムレータと呼ばれる））の初期値。
+ それに畳み込むリストを受け取る

##### 畳み込みの挙動

リストは右からでも左からでも畳み込める。  
畳み込み関数は、アキュムレータとリストの先頭（あるいは最後)の要素を引数として与えられた２引数関数を呼び出す。  
その結果が、新しいアキュムレータになる。

新しいアキュムレータと新しく先頭（あるいは最後）になった要素を引数として再び２引数関数を呼出しまた新しいアキュムレータを作る。  
これをリスト全体を走査しきって単一のアキュムレータの値になるまで繰り返す。

##### foldl で左畳み込み

```haskell
sum' :: (Num a) => [a] -> a
sum' xs = foldl (\acc x -> acc + x) 0 xs
```

関数がカリー化されていることを踏まえると、この実装はもっと簡潔に書くことができる。

```haskell
sum'' :: (Num a) => [a] -> a
sum'' xs = foldl (+) 0
```

(\acc x -> acc + x) は (+) と同じかつ、foldl (+) 0 はリストを取る関数を返すので、引数の xs は省略できる。

##### foldr で右畳み込み

foldr はリストを右から順に処理する点を除いて左畳み込みと似ている。  
※リストは右からは走査できない。foldr はあくまでリストを左から走査するけれど、結果だけみると右から折りたたんだように見えるということ。

ひとつめの引数にリストの値、２つめにアキュムレータを渡す。  
これは直感的には、リストを右から畳み込むのでアキュムレータが右に位置するイメージ。

```haskell
ghci>:t foldl
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b
ghci>:t foldr
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
```

foldr を使って map' を実装する。

```haskell
map' :: (a -> b) -> [a] -> [b]
map' f xs = foldr (\x acc -> f x : acc) [] xs
```

左畳み込みを使って同様の実装もできなくはない

```haskell
map'' :: (a -> b) -> [a] -> [b]
map'' f xs = foldl (\acc x -> acc ++ [f x]) [] xs
```

++関数は、:よりもはるかに遅いので、リストから新しいリストを構築する際は普通は右畳み込みを使う。

##### foldl と foldr の大きな違い

右は無限リストに対しても適応可能、左はダメ。

##### 真偽値を返す関数の実装

指定された値が配列に含まれるかどうかを調べる関数elemの実装。

```haskell
elem' :: (Eq a) => a -> [a] -> Bool
elem' y ys = foldr (\x acc -> if x == y then True else acc) False ys
```

##### foldl1 と foldr1 関数

foldl1 と foldr1 は初期のアキュムレータを明示的に与える必要がない。  
その代わりにリストの先頭（あるいは末尾）の要素を初期アキュムレータとして使い、そこから畳み込みを始める。

maximum関数を実装してみる。

```haskell
maximum' :: (Ord a) => [a] -> a
maximum' = foldl1 max
```

max は２つの数値データを受け取って大きい方を返す。アキュムレータとリストの要素を受け取る。  
よって、畳み込みが完了すると配列の最大値が残る。

##### いくつかの畳み込みの例

```haskell
reverse1 :: [a] -> [a]
reverse1 = foldl (\acc x -> x : acc) []

reverse2 :: [a] -> [a]
reverse2 = foldl (flip (:)) []

product' :: (Num a) => [a] -> a
product' = foldl (*) 1

filter' :: (a -> Bool) -> [a] -> [a]
filter' p = folder (\x acc -> if p x then x : acc else acc) []

last' :: [a] -> a
last' = foldl1 (\_ x -> x)
```

##### 無限リストを畳み込む

畳み込みを一連の関数適用として考えると、foldrが無限リストに対し完璧  
に正しく動作する理由が見えてくる。and を foldr で実装し、前の節のように  
一連の関数適用として書き下してみよう。遅延評価の Haskell で foldr が  
無限リストに対して動作する仕組みがわかるはず。

and関数は、Bool値のリストを引数に取り、どれか１つがFalseならFalseを、  
そうでなければTrueを返す関数。

リストを右から走査し、True を初期アキュムレータとする。
全部がTrueだったときに限りTrueが帰ってほしいので、&&を使う。

&&関数は、2つの引数のどちらかがFalseだったときにFalseを返すので、Falseを含むリストを
操作すればアキュムレータはFalseにセットされ残りの要素がTrueだったとしても最終的な結果はFalseになる。

```haskell
and' ::   [Bool] -> Bool
and' xs = foldr (&&) True xs
```

試してみる。

```haskell
ghci>and' [True, False, True]
False

-- 遅延評価なので最初の False に対してのみ評価する。
ghci>and' (repeat False)
False
```

##### スキャン

`scanl` と `scanr` 関数は、 `foldl` と `foldr` に似ているが、アキュムレータの中間状態のすべてを  
リストとして返す。`scanl1` と `scanr1` 関数は `foldl1` と `foldr1` のアナロジーである。

```haskell
ghci>scanl (+) 0 [3, 5, 2,1]
[0,3,8,10,11]
ghci>scanr (+) 0 [3, 5, 2,1]
[11,8,3,1,0]
ghci>scanl1 (\acc x -> if x > acc then x else acc) [3,4,5,3,7,9,2,1]
[3,4,5,5,7,9,9,9]
ghci>scanl (flip (:)) [] [3,2,1]
[[],[3],[2,3],[1,2,3]]
```

`scanl` は結果の最終要素の最終結果が入る。 `scanr` はリストの先頭に結果が入る。  
畳み込みで実装できるような関数の途中経過をモニターしたいときにスキャンが使える。

*スキャンを使った例*

「自然数の平方根を小さいものから足したとき、1000を超えるのは何個目か？」

すべての自然数の平方数を得るには、単純に `map sqrt [1..]` とするだけでよい。  
和を求めるのに畳み込みを使うことをできるが、加算の途中経過が知りたいのでスキャンを使う。    
スキャンを使えばどこまでが1000より小さいかを調べられる。  

```haskell
ghci>sqrtSums 
131
ghci>sum (map sqrt [1..131])
1005.0942035344083
ghci>sum (map sqrt [1..13])
32.854555867161245
ghci>sum (map sqrt [1..130])
993.6486803921487
```

### $を使った関数適用

$関数、またの名を関数適用演算子について見ていく。  
まずは定義を見てみる。

$関数は単なる関数適用。  
スペースを用いた関数適用は左結合(f a b c は ((f a) b) c を意味する)だが、  
$による関数適用は右結合。

$関数は括弧の数を減らしたいときに役立つ。  
`sum (map sqrt [1..130])` という式を考える。  
$は優先順位が低いので、この式を `sum $ map sqrt [1..130]` と書き換えることができる。  
$ が出てきたらその右側の式が左側の関数に引数として渡される。  

`sqrt 3 + 4 + 9` は3の平方根と4と9を足し合わせる。  
そうでなく、`3 + 4 + 9` の平方根がほしい場合は `sqrt (3 + 4 + 9)` と書かなければならない。  
$を使えば `sqrt $ 3 + 4 + 9` のように記載ができる。

もう一つの例を見てみる。

```haskell
-- 括弧がいっぱいでひどい
ghci>sum  (filter (> 10) (map (*2) [2..10]))
80

-- 少し目に優しく
ghci>sum $ filter (> 10) (map (*2) [2..10])

-- さらにやさしく
ghci>sum $ filter (> 10) $ map (*2) [2..10]
```

$は関数適用それ自身を関数として扱えるようにするために使える。  
例えば関数適用をリストに対して map するようなことができる。

```haskell
-- ($ 3) がリストに対して map される。
ghci>map ($ 3) [(+4), (10*), (^2), sqrt]
[7.0,30.0,9.0,1.7320508075688772]
```

### 関数合成

数学における関数合成は `(f・g)(x) = f(g(x))` のように定義される。  
これは、２つの関数を合成したものは、まず１つの関数を呼び出し、それからもう１つの関すに結果を渡して、  
呼び出したものに等しい、という意味。

Haskell の関数合成もこれとほとんど同じ。  
次のように定義される「.」関数を使って関数合成ができる。

```haskell
(.) :: (b -> c) -> (a -> b) -> a -> c
f . g + \x -> f(g x)
```

fは引数として、gの返り値の型と同じ型の値を受け取らなければならない。  
なので、合成された関数は、gが受け取る型と同じ型の引数を受け取り、  
fが出力する型と同じ型の結果を返す。

例えば、`nagate . (*3)` は数を受け取ってそれを3倍して、それから符号反転する関数を返す。

関数合成の用途としては、他の関数にわたす関数をその場で作るというものがある。  
ラムダ式よりもたいて関数合成のほうが明快で簡潔。  

例えば、数のリストがあって、その全部を負の数にしたいとする。  
各要素の絶対値をとってから符号反転するという方法が考えられる。  

```haskell
-- ラムダ式を使った場合
ghci>map (\x -> negate (abs x)) [5,-3,-6,7,-3,2,-19,24]
[-5,-3,-6,-7,-3,-2,-19,-24]

-- 関数合成を使った場合
ghci>map (negate . abs) [5,-3,-6,7,-3,2,-19,24]
[-5,-3,-6,-7,-3,-2,-19,-24]
```

関数合成は右結合なので一度にたくさんの関数を合成できる。  
式 `f (g (z x))` は `(f . g . z) x` と同じ。

これを踏まえると。

```haskell
-- ラムダ式を使った場合
ghci>map (\xs -> negate (sum (tail xs))) [[1..5], [3..6], [1..7]]
[-14,-15,-27]

-- 関数合成した場合
ghci>map (negate . sum . tail) [[1..5], [3..6], [1..7]]
[-14,-15,-27]
```

というふうに書き表すことができる。

##### 多引数関数の関数合成

```haskell
-- 普通は残り1引数になるまで部分適用しないと関数合成できない。
ghci>sum (replicate 5 6)

-- 上記は以下のように書き換えることができる。
ghci>(sum . replicate 5) 6
30
ghci>sum . replicate 5 $ 6
30
```

関数 replicate 5 が max  6.7 8.9 の結果に適用されそれからその結果に sum が適用されます。  
replicate 関数を部分適用して1つだけ引数を取るようにしている点に注意。

max 5 6 の結果が replicate 5 に渡され、数のリストが結果の値となり、さらにそれが sum に渡される。

たくさん括弧がある式を関数合成を使って書き直したいなら、まず一番内側の関数とその引数を書き出すことから始めまよう。  
それから $ をその前に置いて、その前に置かれていた関数から最後の引数を取り除き、間にドットを置いて合成する。

```haskell
-- 以下は、それぞれ同じ挙動を示す構文
replicate 3 (product (map (*3) (zipWith max [1,2] [4,5])))
replicate 2 . product . map (*3) $ zipWith max [1, 2] [4, 5]
```

閉じ括弧の集まりの直前を見て、右端にある関数とその引数を見つける。  
この例では `zipWith max [1,2] [4,5]` だ。これを取り出して書き付けておきます。

`zipWith max [1,2] [4,5]`

式の終わりに3つも括弧があったなら、いま示した手順で関数合成を使って書き直すチャンス。  
関数合成演算子を使って書き直せるだろう。

##### ポイントフリースタイル

関数合成のもう1つの一般的な使いみちは、ポイントフリースタイルで関数を定義すること。  
例えばこのような関数を書いたとする。

```haskell
sum' :: (Num a) => [a] -> a
sum' xs = foldl (+) 0 xs
```
イコールの両側とも右端が xs 。関数はカリー化されているので、この両側の xs は省略できる。  
`foldl (+) 0` を呼び出すとリストを受け取る関数が作り出されるからである。このようにしてポイントフリースタイルで書ける。

```haskell
sum' :: (Num a) => [a] -> a
sum' = foldl (*) 0
```

もう1つの例として、次の関数のポイントフリースタイルで書いてみる。

`fn x = ceiling (negate (tan (cos (max 50 x))))`

両方の右端に x がありますが、括弧で囲まれているので取り除くことはできない。  
`cos (max 50)` としてしまっては、関数のコサインを取るという、意味をなさないコードになってしまう。  
ここでできるのは fn を関数合成で表現すること。

`fn = ceiling .negate . tan . cos . max 50`

ポイントフリースタイルにすると読みやすく簡潔になることが多々ある。  
データよりも関数に目が行くようになり、どのようにデータが移り変わっていくかでなく、  
どんな関数を合成して何になっているかを考えやすくなるからである。
単純な関数からはじめ、関数合成を糊として使うことにより、より複雑な関数を作り出せばよい。

とはいえ関数が複雑になりすぎると、ポイントフリースタイルでは可読性が悪くなることもある。  
このため、関数合成のチェインはあまり長くしないようにしましょう。let を使って途中の結果にラベルを与え、  
問題を小さな問題に分解すれば、読む人にとってわかりやすいコードになる。

この章の前半で、奇数の平方数で 10000 より小さいものの総和を求める問題を解いた。  
これを関数にすると次のようになる。

```haskell
oddSquareSum :: Integer
oddSquareSum = sum (takeWhile (<10000) (filter odd (map (^2) [1..])))
```

関数合成を使って次のようにも書ける。

```haskell
oddSquareSum :: Integer
oddSquareSum = sum . takeWhile (<10000) . filter odd $ map (^2) [1..]
```

はじめのうちは少し風変わりなスタイルに見えるかもしれないが、すぐに慣れる。  
この書き方は括弧が少ないので視覚的にもノイズが少ない。

このコードを見て「filter odd が map (^2) [1..] に適用され、それから takeWhile (<10000) がその結果に適用され、
最後にその結果に sum が適用される」と読めるようになる。
