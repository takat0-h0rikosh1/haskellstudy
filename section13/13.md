# 13章 モナドがいっぱい

ファンクターは関数で写せる値を表す便利な概念。  
モナドはアプリカティブファンクターの強化版。

## 13.1 アプリカティブファンクターを強化する

アプリカティブ値は、変な値、専門用語でいうと「文脈の不可された値」だとみなせる。  
例えば、文字 a はただの文字だが、Just `a` は何らかの文脈がついている。

Applicative型クラスは、これらの文脈のついた値に、文脈を保ったまま普通の関数を適用させてくれる。

```haskell
(*) <$> Just 2 <*> Just 8

(++) <$> Just "exdeath" <*> Nothing

(-) <$> [3,4] <*> [1,2,3]
```

モナドはある願いを叶えるための、アプリカティブ値の自然な拡張である。  
その願いとは、「普通の値aを取って文脈付きの値を返す関数に、文脈付きの値m aを渡したい」というもの。

下記のような関数が欲しいということ。

```haskell
(>>=) :: (Monad m) => m a -> (a -> m a) -> m b
```

mはモナドのmで文脈を示す。`>>=`はバインドと呼ばれる。

## 13.2 Maybeから始めるモナド


```haskell
-- functor としての動作
fmap (++"!") (Just "window")
fmap (++"!") Nothing

-- applicative としての動作: 値に適応する関数にも文脈がつく
Just (+3) <*> Just 3

Nothing <*> Just "greed"

Just ord <*> Nothing

-- applicative style
max <$> Just 3 <*> Just 6

max <$> Just 3 <*> Nothing
```

`Maybe a` 型の値と `a -> Maybe b` 型の関数を取り、この関数をどうにかして `Maybe a` に適用する。
Maybeがアプリカティブファンクターであるという知識が役に立つ。

`(\x -> Just (x + 1)) 1` は数を取って結果を Just に包む関数。

```haskell
ghci>(\x -> Just (x + 1)) 1
Just 2
ghci>(\x -> Just (x + 1)) 100
Just 101
```

上記の関数にMaybeを食わせるようにしたい。

- Just値が来たときは、Justの中身を取り出してそれを関数に食わせる
- Nothing値が来たときは、関数はあるものの、それを適用すべき値がナッシングというわけなので、結果も Nothing にする

`>>=` とよぶのはやめて `applyMaybe` という名前にする。
これは「Maybe a型の値」と「Maybe bを返す関数」を引数に取り、どうにかしてその関数を「Maybe a」に適用してくれる関数。

```haskell
applyMaybe :: Maybe a -> (a -> Maybe b) -> Maybe b
applyMaybe Nothing f = Nothing
applyMaybe (Just x) f = f x

-- usage
ghci>Just 3 `applyMaybe` \x -> Just (x + 1)
Just 4
ghci>Just "smile" `applyMaybe` \x -> Just (x ++ " :)")
Just "smile :)"
ghci>Nothing `applyMaybe` \x -> Just (x + 1)
Nothing
ghci>Nothing `applyMaybe` \x -> Just (x ++ " :)")
Nothing
```

Just値と関数を引数に applyMaybe を呼び出したときは、単にJustの中の値に関数が適用されている。
Nothing値と関数を引数に呼び出すと、全体の結果がNothingになる。

関数のほうが、Nothingを返す場合は？

```haskell
ghci>Just 3 `applyMaybe` \x -> if x > 2 then Just x else Nothing
Just 3
ghci>Just 1 `applyMaybe` \x -> if x > 2 then Just x else Nothing
Nothing
```

applyMaybe の左辺のモナド値が Nothing だったら全体の結果は Nothing となる。
Maybe をアプリカティブとして使ったときの挙動に似ている。式のどこかに Nothing があったら結果も Nothing になるという挙動だ。

アプリカティブにできることはモナドにもできる。
アプリカティブにできないことがモナドにできることもある。

## 13.3 Monad型クラス

```haskell
class Monad m where
  return :: a -> m a

  (>>=) :: m a -> (a -> m b) -> m b
  (>>) :: m a -> m b -> m b
  x >> y = x >>= \_ -> y

  fail :: String -> m a
  fail msg = error msg
```

1つめのメンバ関数 `return` は Applicative#pure みたいなもん。
値を取ってデフォルトの文脈に入れる。

`>>=` はバインドと呼ばれる。
モナド値を取って、それに「通常の値を取るがモナド値を返す」関数を適用する。

`>>` 文脈を持った値を２つとって左辺の値で上書きする？

最後は `fail` 関数。ユーザーが使うことは滅多になく、もっぱら Haskell システムが呼び出す。
失敗をモナドの文脈で扱えるようにする。

```haskell
ghci>return "WHAT" :: Maybe String
Just "WHAT"
ghci>Just 9 >>= \x -> return (x*10)
Just 90
ghci>Nothing >>= \x -> return (x*10)
Nothing
```

## 13.4 綱渡り

### ひたすらコーディング

バランス棒は、単に整数のペアとして表現できる。ペアの第一成分は左側にいる鳥の数を、第二成分は左側にいるとりの数を表す。

まず、Int型の型シノニムを作り、Birdsと名付ける。
これはそこにいる鳥の数を表す整数。それから（Birds, Birds）の方シノニムを Pole と名付ける。

```haskell
type Birds = Int
type Pole = (Birds, Birds)
```

鳥の数を取って、バランス棒の左側もしくは右側に鳥を止まらせる関数を作る。

```haskell
landLeft :: Birds -> Pole -> Pole
landLeft n (left, right) = (left + n, right)
landRight :: Birds -> Pole -> Pole
landRight n (left, right) = (left, right + n)
```

試していく。

```haskell
ghci>landLeft 2 (0,0)
(2,0)
ghci>landLeft 1 (1,2)
(2,2)
ghci>landRight 1 (1,2)
(1,3)
ghci>landRight (-1) (1,2)
(1,1)
```

鳥を飛び立たせる処理は、負の数の鳥が止まる処理で代用する。
Pole に鳥を止まらせる関数は Pole を返すので、好きなだけ合成できる。

landLeft 1 を (0, 0) に適用すると (1, 0) になる。
それから右側に鳥が1羽止まったら、(1, 1) になる。さらに左側に鳥が2羽とまったら、
(3, 1) になる。

バランス棒を先に書いたほうが読みやすそうなので以下のような関数を作成する。

```haskell
x -: f = f x
```

これで関数を適用するのに、まず引数、次に関数を書けるようになった。

```haskell
ghci>100 -: (*3)
300
ghci>True -: not
False
ghci>:t not
not :: Bool -> Bool
ghci>not False
True
ghci>(0, 0) -: landLeft 2
(2,0)
```

この形式を使えば、鳥を次々と止まらせる処理をさっきより読みやすく書ける。

```haskell
ghci>(0, 0) -: landLeft 1 -: landRight 1 -: landLeft 2
```

こちらのほうが直感的。
(0, 0) から初めて、1羽の鳥が左に、1羽が右に、そして2羽が左にとまったことがすぐにわかる。

ポールに止まった鳥が左右で3羽以上差があった場合にピエールが綱渡りに失敗する実装を入れる、Maybe を使う。

```haskell
landLeft :: Birds -> Pole -> Maybe Pole
landLeft n (left, right)
    | abs ((left + n) - right) < 4 = Just (left + n, right)
    | otherwise                    = Nothing

landRight :: Birds -> Pole -> Maybe Pole
landRight n (left, right)
    | abs (left - (right + n)) < 4 = Just (left, right + n)
    | otherwise                    = Nothing
```

landLeft 関数、landRight 関数は、Pole でなくて Maybe Pole を返すようになった。  
鳥の数と、更新前のバランス棒の状態を引数にとるのは以前と同様だが、たくさん鳥が来たときはバランスを失った  
ピエールを放り出す検査が入るようになった。このコードでは、ガード記法を使って、更新後の左右の鳥の数の差が  
4より小さいかを判定している。

もし、4より小さいなら、新しいバランス棒の状態を Just に包んで返す。差が4以上になった場合は失敗を意味する  
Nothing を返す。

```haskell
ghci>landLeft 2 (0, 0)
Just (2,0)
ghci>landLeft 10 (0, 3)
Nothing
```

### ロープの上のバナナ

いきなりピエールを滑らせて落とす関数を作る。  
この関数をバナナと呼ぶ。

```haskell
banana :: Pole -> Maybe Pole
banana _ = Nothing
```

この関数は鳥をとまらせる関数と混ぜて使える。  
banana は引数に何を渡されようと、無視して失敗を返すようにできているので、  
banana を呼べばかならずピエールを落っことせる。

```haskell
ghci>return (0,0) >>= landLeft 1 >>= banana >>= landRight 1
Nothing
```

上の例では、banana に渡るのは Just (1, 0) というかなり良いバランスの値だが、banana はお構いなしに Nothing を返すので、以降すべての結果は Nothing になってしまう。残念でした。

ところで、入力に関係なく既定のモナド値を返す関数だったら、自作せずとも >> 関数を使うという手がある。これが >> のデフォルトの実装

```haskell
(>>) :: (Monad m) => m a -> m b -> m b
m >> n = m >>= \_ -> n
```

普通の関数なら、引数を無視して既定の値を返すような関数の結果は、その既定値そのものである。ところが、モナド値を扱う場合は、モナドとしての文脈と意味を考慮する必要がある。Maybe版の >> の動作は、こんな感じ。

```haskell
ghci>Nothing >> Just 3
Nothing
ghci>Just 3 >> Just 4
Just 4
ghci>Just 3 >> Nothing
Nothing
```

1番目の例では、Maybeモナドの文脈が考慮された結果、「規定値」であるはずの Just 3 が失敗に置き換わっている。>> を >>= \_ -> で置き換えてみれば何が起こっているのか簡単に理解できる。

`>>=` で連結した処理中での banana 関数は、>> と Nothing という、失敗することが保証された組み合わせで置き換えられる。

```haskell
ghci>return (0, 0) >>= landLeft 1 >> Nothing >>= landRight 1
Nothing
```

ところで、Maybe を失敗の文脈付きの値として扱って関数に食わせるという賢明な選択をしなかったら、どうなっていただろうか？

バランス棒に鳥をとまらせる一連の処理はこのようになったはずです。

```haskell
routine :: Maybe Pole
routine = case landLeft 1 (0, 0) of
    Nothing -> Nothing
    Just pole1 -> case landRight 4 pole1 of
        Nothing -> Nothing
        Just pole2 -> case landLeft 2 pole2 of
            Nothing -> Nothing
            Just pole3 -> landLeft 1 pole3
```

成功していた場合は、右側に鳥をとめる処理に進み、また場合分けをして...、  
という繰り返し。この巨大で見にくいコードを、>>= による素敵なモナド適用の連鎖で書き直すのは、Maybeモナド普及コードの定番。Maybeもなどを使うと、失敗するかもしれない処理が連続するコード簡潔に書くことができる。

## 13.5 do記法

Haskell にとってモナドはとても便利なので、モナド専用構文まで用意されている。  
その名はdo記法。do記法はすでに第8章で複数のI/Oアクションを1つに糊付けするときに使った。

実はdo記法はIOモナドだけじゃなくあらゆるモナドに使える。といっても基本は同じで、do記法は複数のモナド値を糊付けするもの。

