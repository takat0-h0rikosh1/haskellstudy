`Maybe a` 型の値と `a -> Maybe b` 型の関数を取り、この関数をどうにかして `Maybe a` に適用する。
Maybeがアプリカティブファンクターであるという知識が役に立つ。

`(\x -> Just (x + 1)) 1` は数を取って結果を Just に包む関数。

```haskell
ghci>(\x -> Just (x + 1)) 1
Just 2
ghci>(\x -> Just (x + 1)) 100
Just 101
```

上記の関数にMaybeを食わせるようにしたい。

- Just値が来たときは、Justの中身を取り出してそれを関数に食わせる
- Nothing値が来たときは、関数はあるものの、それを適用すべき値がナッシングというわけなので、結果も Nothing にする

`>>=` とよぶのはやめて `applyMaybe` という名前にする。
これは「Maybe a型の値」と「Maybe bを返す関数」を引数に取り、どうにかしてその関数を「Maybe a」に適用してくれる関数。

```haskell
applyMaybe :: Maybe a -> (a -> Maybe b) -> Maybe b
applyMaybe Nothing f = Nothing
applyMaybe (Just x) f = f x

-- usage
ghci>Just 3 `applyMaybe` \x -> Just (x + 1)
Just 4
ghci>Just "smile" `applyMaybe` \x -> Just (x ++ " :)")
Just "smile :)"
ghci>Nothing `applyMaybe` \x -> Just (x + 1)
Nothing
ghci>Nothing `applyMaybe` \x -> Just (x ++ " :)")
Nothing
```

Just値と関数を引数に applyMaybe を呼び出したときは、単にJustの中の値に関数が適用されている。
Nothing値と関数を引数に呼び出すと、全体の結果がNothingになる。

関数のほうが、Nothingを返す場合は？

```haskell
ghci>Just 3 `applyMaybe` \x -> if x > 2 then Just x else Nothing
Just 3
ghci>Just 1 `applyMaybe` \x -> if x > 2 then Just x else Nothing
Nothing
```

applyMaybe の左辺のモナド値が Nothing だったら全体の結果は Nothing となる。
Maybe をアプリカティブとして使ったときの挙動に似ている。式のどこかに Nothing があったら結果も Nothing になるという挙動だ。

アプリカティブにできることはモナドにもできる。
アプリカティブにできないことがモナドにできることもある。

## 13.3 Monad型クラス

```haskell
class Monad m where
  return :: a -> m a

  (>>=) :: m a -> (a -> m b) -> m b
  (>>) :: m a -> m b -> m b
  x >> y = x >>= \_ -> y

  fail :: String -> m a
  fail msg = error msg
```

1つめのメンバ関数 `return` は Applicative#pure みたいなもん。
値を取ってデフォルトの文脈に入れる。

`>>=` はバインドと呼ばれる。
モナド値を取って、それに「通常の値を取るがモナド値を返す」関数を適用する。

`>>` 文脈を持った値を２つとって左辺の値で上書きする？

最後は `fail` 関数。ユーザーが使うことは滅多になく、もっぱら Haskell システムが呼び出す。
失敗をモナドの文脈で扱えるようにする。

```haskell
ghci>return "WHAT" :: Maybe String
Just "WHAT"
ghci>Just 9 >>= \x -> return (x*10)
Just 90
ghci>Nothing >>= \x -> return (x*10)
Nothing
```

## 13.4 綱渡り

### ひたすらコーディング

バランス棒は、単に整数のペアとして表現できる。ペアの第一成分は左側にいる鳥の数を、第二成分は左側にいるとりの数を表す。

まず、Int型の型シノニムを作り、Birdsと名付ける。
これはそこにいる鳥の数を表す整数。それから（Birds, Birds）の方シノニムを Pole と名付ける。

```haskell
type Birds = Int
type Pole = (Birds, Birds)
```

鳥の数を取って、バランス棒の左側もしくは右側に鳥を止まらせる関数を作る。

```haskell
landLeft :: Birds -> Pole -> Pole
landLeft n (left, right) = (left + n, right)
landRight :: Birds -> Pole -> Pole
landRight n (left, right) = (left, right + n)
```

試していく。

```haskell
ghci>landLeft 2 (0,0)
(2,0)
ghci>landLeft 1 (1,2)
(2,2)
ghci>landRight 1 (1,2)
(1,3)
ghci>landRight (-1) (1,2)
(1,1)
```

鳥を飛び立たせる処理は、負の数の鳥が止まる処理で代用する。
Pole に鳥を止まらせる関数は Pole を返すので、好きなだけ合成できる。

landLeft 1 を (0, 0) に適用すると (1, 0) になる。
それから右側に鳥が1羽止まったら、(1, 1) になる。さらに左側に鳥が2羽とまったら、
(3, 1) になる。

バランス棒を先に書いたほうが読みやすそうなので以下のような関数を作成する。

```haskell
x -: f = f x
```

これで関数を適用するのに、まず引数、次に関数を書けるようになった。

```haskell
ghci>100 -: (*3)
300
ghci>True -: not
False
ghci>:t not
not :: Bool -> Bool
ghci>not False
True
ghci>(0, 0) -: landLeft 2
(2,0)
```

この形式を使えば、鳥を次々と止まらせる処理をさっきより読みやすく書ける。

```haskell
ghci>(0, 0) -: landLeft 1 -: landRight 1 -: landLeft 2
```

こちらのほうが直感的。
(0, 0) から初めて、1羽の鳥が左に、1羽が右に、そして2羽が左にとまったことがすぐにわかる。

ポールに止まった鳥が左右で3羽以上差があった場合にピエールが綱渡りに失敗する実装を入れる、Maybe を使う。

```haskell
landLeft :: Birds -> Pole -> Maybe Pole
landLeft n (left, right)
    | abs ((left + n) - right) < 4 = Just (left + n, right)
    | otherwise                    = Nothing

landRight :: Birds -> Pole -> Maybe Pole
landRight n (left, right)
    | abs (left - (right + n)) < 4 = Just (left, right + n)
    | otherwise                    = Nothing
```

landLeft 関数、landRight 関数は、Pole でなくて Maybe Pole を返すようになった。  
鳥の数と、更新前のバランス棒の状態を引数にとるのは以前と同様だが、たくさん鳥が来たときはバランスを失った  
ピエールを放り出す検査が入るようになった。このコードでは、ガード記法を使って、更新後の左右の鳥の数の差が  
4より小さいかを判定している。

もし、4より小さいなら、新しいバランス棒の状態を Just に包んで返す。差が4以上になった場合は失敗を意味する  
Nothing を返す。

```haskell
ghci>landLeft 2 (0, 0)
Just (2,0)
ghci>landLeft 10 (0, 3)
Nothing
```