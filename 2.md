### 関数も型を持つ

関数も型を持つ。明示的に型宣言を与えることもできる。
リスト内包表記に型宣言を与える。

```
# removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]
ghci>:t removeNonUppercase
removeNonUppercase :: [Char] -> [Char]
```

関数が複数の引数を持つ場合

```
# addThree x y z = x + y + z 
ghci>:t addThree
addThree :: Num a => a -> a -> a -> a
```

タプルも型だがその定義は要素の数とそれぞれの型によって決まる。
なお、タプル要素の最大数は62個（そんなに持つことはないだろう)

### 型変数

`head`関数の型定義を見てみる。

```
ghci>:t head
head :: [a] -> a
```

`a`とはなんだろうか？
この`a`は型変数と呼ばれる。どんな型も取りうることを示している。
※他言語のジェネリクスのようなもの。

型変数を用いた関数は多層的関数と呼ばれる。

### 型クラス

型クラスは何らかの振る舞いを定義するインターフェイス。
ある型クラスのインスタンスである型は、その型クラスの振る舞いを実装する。

##### もっと具体的に

型クラスは関数の集まりを定める。
ある型クラスに属する関数のことを、その型クラスのメソッドと呼ぶこともある。

ある型を型クラスのインスタンスにしようと考えたときには、それらの関数がその型ではどういう意味をなすのかを定義する。
等値性を定義する型クラスが良い例となる。多くの方についてその値の等値性を `==` 演算子を使って比較できる。

```
ghci>:t (==)
(==) :: Eq a => a -> a -> Bool
```

(==) は実際には関数である。+, -, *, / などほとんどすべての演算子も同様。  
関数の名前が特殊文字のみからなる場合、その関数はデフォルトで中置関数になる。  
その型を調べたり、他の関数に渡したり、前置関数として呼び出したい場合は、上記の例のように丸括弧で囲む必要がある。

この例には見慣れないものが含まれている。 => というシンボルである。
このシンボルよりも前にあるものは型クラス制約と呼ばれる。この例の型宣言は、
「等値生関数は、同じ型の任意の2つの引数を取り、Bool を返す。  
引数の2つの値の型は Eq クラスのインスタンスでなければならない」と読める。

Eq型クラスは、等値性をテストするためのインターフェイスを提供する。
ある型の2つの値の等値性を比較することに意味があるなら、その型はEq型クラスのインスタンスにできる。Haskellのすべての標準型(I/O型と関数を除く)はEqのインスタンス。

### よく使われる型クラス

##### Eq型クラス

Eqは等値性をテストできる型。Eqのインスタンスあ実装スべき関数は `==` と `\=`。  

```
ghci>5 == 5
True
ghci>5 /= 5
False
ghci>'a' == 'a'
True
ghci>"Ho Ho" == "Ho Ho"
True
ghci>3.432 == 3.432
True
```

##### Ord型クラス

Ordは何らかの順序を付けられる型のための型クラス。

```
ghci>:t (>)
(>) :: Ord a => a -> a -> Bool
ghci>"Abrakadabra" < "Zebra"
True
ghci>"Abrakadabra" `compare` "Zebra"
LT
ghci>5 >= 2
True
ghci>5 `compare` 3
GT
ghci>'b' > 'a'
True
```

##### Show型クラス

Show型クラスのインスタンスになっていれば、文字列として表現できる。

```
ghci>show 3
"3"
ghci>show 5.334
"5.334"
ghci>show True
"True"
```
