# 7章 型や型クラスを自分つくる

### 7.2 形づくる

長方形と円という二種類の図形を扱う。

```haskell
data Shape = Circle Float Float Float |
             Rectangle Float Float Float Float
```

これらの値はコンスとラスクに与える引数の型。
Circle: 最初の２つのフィールドは円の中心の座標で３つ目のフィールドは円の半径。
Rectangle: 最初の２つは左下の角、後の２つは右下の角の座標。

それぞれの面積を求める関数。

```haskell
area :: Shape -> Float
area (Circle _ _ r) = pi * r ^ 2
area (Rectangle x1 y1 x2 y2) = (abs $ x2 - x1) * (abs $ y2 - y1)
```

Circle x y z をプロンプトから表示できるようにする

```haskell
data Shape = Circle Float Float Float |
             Rectangle Float Float Float Float
    deriving (Show)
```

値コンストラクタは関数なので普通に map したり部分適用したりできる。

```haskell
map (Circle 10 20) [4,5,6,6]
```

##### Pointデータ型で形を整える

もっとよくできるので二次元空間の点を表す中間データ構造を作る。

```haskell
data Point = Point Float Float deriving (Show)   
data Shape = Circle Point Float | Rectangle Point Point deriving (Show)
```

are関数にも反映させる

```haskell
area :: Shape -> Float
area (Circle _ r) = pi * r ^ 2
area (Rectangle (Point x1 y1) (Point x2 y2)) = (abs $ x2 - x1) * (abs $ y2 - y1)
```

使ってみる。

```haskell
area (Rectangle (Point 0 0) (Point 100 100))
area (Circle (Point 0 0) 24)
```

図形を動かす関数も欲しい。

```haskell
nudge :: Shape -> Float -> Float -> Shape
nudge (Circle (Point x y) r) a b = Circle (Point (x+a) (y+b)) r
nudge (Rectangle (Point x1 y1) (Point x2 y2)) a b
    = Rectangle (Point (x1+a) (y1+a)) (Point (x2+a) (y2+b))
```

指定したサイズの図形を原点に作る補助関数を使ってそれから移動させる。

```haskell
baseCircle :: Float -> Shape
baseCircle r = Circle (Point 0 0) r
```

幅と高さを取って、左下の頂点が原点にある長方形を作る関数を作る。

```haskell
baseRect :: Float -> Float -> Shape
baseRect width height = Rectangle (Point 0 0) (Point width height)
```

これで座標系の原点に図形を作って望みの場所まで移動させることができる。

```haskell
nudge (baseRect 40 100) 60 23
```

##### Shape モジュールとしてエクスポートする

関数のエクスポートしたい箇所に型名をかくだけ。
値コンストラクタをエクスポートしたい場合は、型名の後に括弧を追加し、その中にカンマ区切りで値コンストラクタを書く。

```haskell
module Shape
( Point(..)
, Shape(..)
, area
, nudge
, baseCircle
, baseRect
) where
```

### レコード構文

人物のデータ型を作る。

```haskell
data Person = Person String String Int Float String String
    deriving (Show)

let guy = Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate"
```

特定の情報を取り出す

```haskell
data Person = Person { firstName :: String
, lastName :: String
, age :: Int
, height :: Float
, phoneNumber :: String
, flavor :: String 
} deriving (Show)
```

上記のように宣言すると関数を自動で作ってくれる
生成された関数を使ってみる

```haskell
ghci> firstName guy
"Buddy"
```

Showインスタンスを自動導出するとき、レコード構文を使って定義しインスタンス化した型は、
そうでない型とは違う表示の仕方になる。

```haskell
data Car = Car String String Int deriving (Show)
```

レコード構文の場合

```haskell
data Car = Car { company :: String
, model :: String
, year :: Int
} deriving (Show)
```

### 7.4 型引数

```haskell
data Car a b c = Car{ company :: a
, model :: b
, year :: c
} deriving (Show)
```

```haskell
data Car a b c = Car{ company :: a
, model :: b
, year :: c
} deriving (Show)

data Car = Car { company :: String
, model :: String
, year :: Int
} deriving (Show)

tellCar :: Car -> String
tellCar (Car {company = c, model = m, year = y}) = "This " ++ c ++ " " ++ m ++ " was made in " ++ show y

ghci> let stang = Car {company="Ford", model="Mustang", year=1967}
ghci>tellCar stang
"This Ford Mustang was made in 1967"
```

#####  3次元ベクトル

